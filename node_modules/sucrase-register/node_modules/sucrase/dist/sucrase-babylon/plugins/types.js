"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../parser/base");
const expression_1 = require("../parser/expression");
const tokenizer_1 = require("../tokenizer");
const flow_1 = require("./flow");
const typescript_1 = require("./typescript");
/**
 * Common parser code for TypeScript and Flow.
 */
// An apparent conditional expression could actually be an optional parameter in an arrow function.
function typedParseConditional(noIn, startPos) {
    // only do the expensive clone if there is a question mark
    // and if we come from inside parens
    if (!tokenizer_1.match(9728 /* question */)) {
        expression_1.baseParseConditional(noIn, startPos);
        return;
    }
    const snapshot = base_1.state.snapshot();
    try {
        expression_1.baseParseConditional(noIn, startPos);
        return;
    }
    catch (err) {
        if (!(err instanceof SyntaxError)) {
            // istanbul ignore next: no such error is expected
            throw err;
        }
        base_1.state.restoreFromSnapshot(snapshot);
    }
}
exports.typedParseConditional = typedParseConditional;
// Note: These "type casts" are *not* valid TS expressions.
// But we parse them here and change them when completing the arrow function.
function typedParseParenItem() {
    if (tokenizer_1.eat(9728 /* question */)) {
        base_1.state.tokens[base_1.state.tokens.length - 1].isType = true;
    }
    if (tokenizer_1.match(8192 /* colon */)) {
        if (base_1.hasPlugin("typescript")) {
            typescript_1.tsParseTypeAnnotation();
        }
        else if (base_1.hasPlugin("flow")) {
            flow_1.flowParseTypeAnnotation();
        }
    }
}
exports.typedParseParenItem = typedParseParenItem;
