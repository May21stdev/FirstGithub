"use strict";
/* eslint max-len: 0 */
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../parser/base");
const expression_1 = require("../parser/expression");
const statement_1 = require("../parser/statement");
const util_1 = require("../parser/util");
const tokenizer_1 = require("../tokenizer");
function isMaybeDefaultImport(lookahead) {
    return ((lookahead.type === 2048 /* name */ || !!(lookahead.type & 16 /* IS_KEYWORD */)) &&
        lookahead.contextualKeyword !== 10 /* _from */);
}
function flowParseTypeInitialiser(tok) {
    tokenizer_1.runInTypeContext(0, () => {
        util_1.expect(tok || 8192 /* colon */);
        flowParseType();
    });
}
function flowParsePredicate() {
    util_1.expect(24075 /* modulo */);
    util_1.expectContextual(5 /* _checks */);
    if (tokenizer_1.eat(6144 /* parenL */)) {
        expression_1.parseExpression();
        util_1.expect(6656 /* parenR */);
    }
}
function flowParseTypeAndPredicateInitialiser() {
    tokenizer_1.runInTypeContext(0, () => {
        util_1.expect(8192 /* colon */);
        if (tokenizer_1.match(24075 /* modulo */)) {
            flowParsePredicate();
        }
        else {
            flowParseType();
            if (tokenizer_1.match(24075 /* modulo */)) {
                flowParsePredicate();
            }
        }
    });
}
function flowParseDeclareClass() {
    tokenizer_1.next();
    flowParseInterfaceish(/* isClass */ true);
}
function flowParseDeclareFunction() {
    tokenizer_1.next();
    expression_1.parseIdentifier();
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    util_1.expect(6144 /* parenL */);
    flowParseFunctionTypeParams();
    util_1.expect(6656 /* parenR */);
    flowParseTypeAndPredicateInitialiser();
    util_1.semicolon();
}
function flowParseDeclare() {
    if (tokenizer_1.match(41488 /* _class */)) {
        flowParseDeclareClass();
    }
    else if (tokenizer_1.match(34320 /* _function */)) {
        flowParseDeclareFunction();
    }
    else if (tokenizer_1.match(37392 /* _var */)) {
        flowParseDeclareVariable();
    }
    else if (util_1.isContextual(19 /* _module */)) {
        if (tokenizer_1.lookaheadType() === 9216 /* dot */) {
            flowParseDeclareModuleExports();
        }
        else {
            flowParseDeclareModule();
        }
    }
    else if (util_1.isContextual(30 /* _type */)) {
        flowParseDeclareTypeAlias();
    }
    else if (util_1.isContextual(22 /* _opaque */)) {
        flowParseDeclareOpaqueType();
    }
    else if (util_1.isContextual(15 /* _interface */)) {
        flowParseDeclareInterface();
    }
    else if (tokenizer_1.match(42512 /* _export */)) {
        flowParseDeclareExportDeclaration();
    }
    else {
        throw util_1.unexpected();
    }
}
function flowParseDeclareVariable() {
    tokenizer_1.next();
    flowParseTypeAnnotatableIdentifier();
    util_1.semicolon();
}
function flowParseDeclareModule() {
    tokenizer_1.next();
    if (tokenizer_1.match(1536 /* string */)) {
        expression_1.parseExprAtom();
    }
    else {
        expression_1.parseIdentifier();
    }
    util_1.expect(4096 /* braceL */);
    while (!tokenizer_1.match(5120 /* braceR */)) {
        if (tokenizer_1.match(43024 /* _import */)) {
            tokenizer_1.next();
            statement_1.parseImport();
        }
    }
    util_1.expect(5120 /* braceR */);
}
function flowParseDeclareExportDeclaration() {
    util_1.expect(42512 /* _export */);
    if (tokenizer_1.eat(31760 /* _default */)) {
        if (tokenizer_1.match(34320 /* _function */) || tokenizer_1.match(41488 /* _class */)) {
            // declare export default class ...
            // declare export default function ...
            flowParseDeclare();
        }
        else {
            // declare export default [type];
            flowParseType();
            util_1.semicolon();
        }
    }
    else if (tokenizer_1.match(37392 /* _var */) || // declare export var ...
        tokenizer_1.match(34320 /* _function */) || // declare export function ...
        tokenizer_1.match(41488 /* _class */) || // declare export class ...
        util_1.isContextual(22 /* _opaque */) // declare export opaque ..
    ) {
        flowParseDeclare();
    }
    else if (tokenizer_1.match(24587 /* star */) || // declare export * from ''
        tokenizer_1.match(4096 /* braceL */) || // declare export {} ...
        util_1.isContextual(15 /* _interface */) || // declare export interface ...
        util_1.isContextual(30 /* _type */) || // declare export type ...
        util_1.isContextual(22 /* _opaque */) // declare export opaque type ...
    ) {
        statement_1.parseExport();
    }
    else {
        throw util_1.unexpected();
    }
}
function flowParseDeclareModuleExports() {
    util_1.expectContextual(19 /* _module */);
    util_1.expect(9216 /* dot */);
    util_1.expectContextual(9 /* _exports */);
    flowParseTypeAnnotation();
    util_1.semicolon();
}
function flowParseDeclareTypeAlias() {
    tokenizer_1.next();
    flowParseTypeAlias();
}
function flowParseDeclareOpaqueType() {
    tokenizer_1.next();
    flowParseOpaqueType(true);
}
function flowParseDeclareInterface() {
    tokenizer_1.next();
    flowParseInterfaceish();
}
// Interfaces
function flowParseInterfaceish(isClass) {
    flowParseRestrictedIdentifier();
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    if (tokenizer_1.eat(42000 /* _extends */)) {
        do {
            flowParseInterfaceExtends();
        } while (!isClass && tokenizer_1.eat(7168 /* comma */));
    }
    if (util_1.isContextual(18 /* _mixins */)) {
        tokenizer_1.next();
        do {
            flowParseInterfaceExtends();
        } while (tokenizer_1.eat(7168 /* comma */));
    }
    if (util_1.isContextual(13 /* _implements */)) {
        tokenizer_1.next();
        do {
            flowParseInterfaceExtends();
        } while (tokenizer_1.eat(7168 /* comma */));
    }
    flowParseObjectType(true, false);
}
function flowParseInterfaceExtends() {
    flowParseQualifiedTypeIdentifier(false);
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterInstantiation();
    }
}
function flowParseInterface() {
    flowParseInterfaceish();
}
function flowParseRestrictedIdentifier() {
    expression_1.parseIdentifier();
}
function flowParseTypeAlias() {
    flowParseRestrictedIdentifier();
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    flowParseTypeInitialiser(14368 /* eq */);
    util_1.semicolon();
}
function flowParseOpaqueType(declare) {
    util_1.expectContextual(30 /* _type */);
    flowParseRestrictedIdentifier();
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    // Parse the supertype
    if (tokenizer_1.match(8192 /* colon */)) {
        flowParseTypeInitialiser(8192 /* colon */);
    }
    if (!declare) {
        flowParseTypeInitialiser(14368 /* eq */);
    }
    util_1.semicolon();
}
function flowParseTypeParameter() {
    flowParseVariance();
    flowParseTypeAnnotatableIdentifier();
    if (tokenizer_1.eat(14368 /* eq */)) {
        flowParseType();
    }
}
function flowParseTypeParameterDeclaration() {
    tokenizer_1.runInTypeContext(0, () => {
        // istanbul ignore else: this condition is already checked at all call sites
        if (tokenizer_1.match(21000 /* lessThan */) || tokenizer_1.match(28160 /* typeParameterStart */)) {
            tokenizer_1.next();
        }
        else {
            util_1.unexpected();
        }
        do {
            flowParseTypeParameter();
            if (!tokenizer_1.match(21512 /* greaterThan */)) {
                util_1.expect(7168 /* comma */);
            }
        } while (!tokenizer_1.match(21512 /* greaterThan */));
        util_1.expect(21512 /* greaterThan */);
    });
}
exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;
function flowParseTypeParameterInstantiation() {
    tokenizer_1.runInTypeContext(0, () => {
        util_1.expect(21000 /* lessThan */);
        while (!tokenizer_1.match(21512 /* greaterThan */)) {
            flowParseType();
            if (!tokenizer_1.match(21512 /* greaterThan */)) {
                util_1.expect(7168 /* comma */);
            }
        }
        util_1.expect(21512 /* greaterThan */);
    });
}
function flowParseObjectPropertyKey() {
    if (tokenizer_1.match(0 /* num */) || tokenizer_1.match(1536 /* string */)) {
        expression_1.parseExprAtom();
    }
    else {
        expression_1.parseIdentifier();
    }
}
function flowParseObjectTypeIndexer() {
    util_1.expect(3072 /* bracketL */);
    if (tokenizer_1.lookaheadType() === 8192 /* colon */) {
        flowParseObjectPropertyKey();
        flowParseTypeInitialiser();
    }
    else {
        flowParseType();
    }
    util_1.expect(3584 /* bracketR */);
    flowParseTypeInitialiser();
}
function flowParseObjectTypeMethodish() {
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    util_1.expect(6144 /* parenL */);
    while (!tokenizer_1.match(6656 /* parenR */) && !tokenizer_1.match(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
        if (!tokenizer_1.match(6656 /* parenR */)) {
            util_1.expect(7168 /* comma */);
        }
    }
    if (tokenizer_1.eat(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
    }
    util_1.expect(6656 /* parenR */);
    flowParseTypeInitialiser();
}
function flowParseObjectTypeCallProperty() {
    flowParseObjectTypeMethodish();
}
function flowParseObjectType(allowStatic, allowExact) {
    let endDelim;
    if (allowExact && tokenizer_1.match(4608 /* braceBarL */)) {
        util_1.expect(4608 /* braceBarL */);
        endDelim = 5632 /* braceBarR */;
    }
    else {
        util_1.expect(4096 /* braceL */);
        endDelim = 5120 /* braceR */;
    }
    while (!tokenizer_1.match(endDelim)) {
        let isStatic = false;
        if (allowStatic && util_1.isContextual(29 /* _static */) && tokenizer_1.lookaheadType() !== 8192 /* colon */) {
            tokenizer_1.next();
            isStatic = true;
        }
        flowParseVariance();
        if (tokenizer_1.match(3072 /* bracketL */)) {
            flowParseObjectTypeIndexer();
        }
        else if (tokenizer_1.match(6144 /* parenL */) || tokenizer_1.match(21000 /* lessThan */)) {
            flowParseObjectTypeCallProperty();
        }
        else {
            if (util_1.isContextual(11 /* _get */) || util_1.isContextual(28 /* _set */)) {
                const lookahead = tokenizer_1.lookaheadType();
                if (lookahead === 2048 /* name */ || lookahead === 1536 /* string */ || lookahead === 0 /* num */) {
                    tokenizer_1.next();
                }
            }
            flowParseObjectTypeProperty();
        }
        flowObjectTypeSemicolon();
    }
    util_1.expect(endDelim);
}
function flowParseObjectTypeProperty() {
    if (tokenizer_1.match(11776 /* ellipsis */)) {
        util_1.expect(11776 /* ellipsis */);
        flowParseType();
    }
    else {
        flowParseObjectPropertyKey();
        if (tokenizer_1.match(21000 /* lessThan */) || tokenizer_1.match(6144 /* parenL */)) {
            // This is a method property
            flowParseObjectTypeMethodish();
        }
        else {
            tokenizer_1.eat(9728 /* question */);
            flowParseTypeInitialiser();
        }
    }
}
function flowObjectTypeSemicolon() {
    if (!tokenizer_1.eat(7680 /* semi */) && !tokenizer_1.eat(7168 /* comma */) && !tokenizer_1.match(5120 /* braceR */) && !tokenizer_1.match(5632 /* braceBarR */)) {
        util_1.unexpected();
    }
}
function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
    if (!initialIdAlreadyParsed) {
        expression_1.parseIdentifier();
    }
    while (tokenizer_1.eat(9216 /* dot */)) {
        expression_1.parseIdentifier();
    }
}
function flowParseGenericType() {
    flowParseQualifiedTypeIdentifier(true);
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterInstantiation();
    }
}
function flowParseTypeofType() {
    util_1.expect(46736 /* _typeof */);
    flowParsePrimaryType();
}
function flowParseTupleType() {
    util_1.expect(3072 /* bracketL */);
    // We allow trailing commas
    while (base_1.state.pos < base_1.input.length && !tokenizer_1.match(3584 /* bracketR */)) {
        flowParseType();
        if (tokenizer_1.match(3584 /* bracketR */)) {
            break;
        }
        util_1.expect(7168 /* comma */);
    }
    util_1.expect(3584 /* bracketR */);
}
function flowParseFunctionTypeParam() {
    const lookahead = tokenizer_1.lookaheadType();
    if (lookahead === 8192 /* colon */ || lookahead === 9728 /* question */) {
        expression_1.parseIdentifier();
        tokenizer_1.eat(9728 /* question */);
        flowParseTypeInitialiser();
    }
    else {
        flowParseType();
    }
}
function flowParseFunctionTypeParams() {
    while (!tokenizer_1.match(6656 /* parenR */) && !tokenizer_1.match(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
        if (!tokenizer_1.match(6656 /* parenR */)) {
            util_1.expect(7168 /* comma */);
        }
    }
    if (tokenizer_1.eat(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
    }
}
// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
    let isGroupedType = false;
    const oldNoAnonFunctionType = base_1.state.noAnonFunctionType;
    switch (base_1.state.type) {
        case 2048 /* name */: {
            expression_1.parseIdentifier();
            flowParseGenericType();
            return;
        }
        case 4096 /* braceL */:
            flowParseObjectType(false, false);
            return;
        case 4608 /* braceBarL */:
            flowParseObjectType(false, true);
            return;
        case 3072 /* bracketL */:
            flowParseTupleType();
            return;
        case 21000 /* lessThan */:
            flowParseTypeParameterDeclaration();
            util_1.expect(6144 /* parenL */);
            flowParseFunctionTypeParams();
            util_1.expect(6656 /* parenR */);
            util_1.expect(10752 /* arrow */);
            flowParseType();
            return;
        case 6144 /* parenL */:
            tokenizer_1.next();
            // Check to see if this is actually a grouped type
            if (!tokenizer_1.match(6656 /* parenR */) && !tokenizer_1.match(11776 /* ellipsis */)) {
                if (tokenizer_1.match(2048 /* name */)) {
                    const token = tokenizer_1.lookaheadType();
                    isGroupedType = token !== 9728 /* question */ && token !== 8192 /* colon */;
                }
                else {
                    isGroupedType = true;
                }
            }
            if (isGroupedType) {
                base_1.state.noAnonFunctionType = false;
                flowParseType();
                base_1.state.noAnonFunctionType = oldNoAnonFunctionType;
                // A `,` or a `) =>` means this is an anonymous function type
                if (base_1.state.noAnonFunctionType ||
                    !(tokenizer_1.match(7168 /* comma */) || (tokenizer_1.match(6656 /* parenR */) && tokenizer_1.lookaheadType() === 10752 /* arrow */))) {
                    util_1.expect(6656 /* parenR */);
                    return;
                }
                else {
                    // Eat a comma if there is one
                    tokenizer_1.eat(7168 /* comma */);
                }
            }
            flowParseFunctionTypeParams();
            util_1.expect(6656 /* parenR */);
            util_1.expect(10752 /* arrow */);
            flowParseType();
            return;
        case 23690 /* minus */:
            tokenizer_1.next();
            expression_1.parseLiteral();
            return;
        case 1536 /* string */:
        case 0 /* num */:
        case 44560 /* _true */:
        case 45072 /* _false */:
        case 44048 /* _null */:
        case 40464 /* _this */:
        case 47248 /* _void */:
        case 24587 /* star */:
            tokenizer_1.next();
            return;
        default:
            if (base_1.state.type === 46736 /* _typeof */) {
                flowParseTypeofType();
                return;
            }
    }
    throw util_1.unexpected();
}
function flowParsePostfixType() {
    flowParsePrimaryType();
    while (!util_1.canInsertSemicolon() && tokenizer_1.match(3072 /* bracketL */)) {
        util_1.expect(3072 /* bracketL */);
        util_1.expect(3584 /* bracketR */);
    }
}
function flowParsePrefixType() {
    if (tokenizer_1.eat(9728 /* question */)) {
        flowParsePrefixType();
    }
    else {
        flowParsePostfixType();
    }
}
function flowParseAnonFunctionWithoutParens() {
    flowParsePrefixType();
    if (!base_1.state.noAnonFunctionType && tokenizer_1.eat(10752 /* arrow */)) {
        flowParseType();
    }
}
function flowParseIntersectionType() {
    tokenizer_1.eat(19974 /* bitwiseAND */);
    flowParseAnonFunctionWithoutParens();
    while (tokenizer_1.eat(19974 /* bitwiseAND */)) {
        flowParseAnonFunctionWithoutParens();
    }
}
function flowParseUnionType() {
    tokenizer_1.eat(18948 /* bitwiseOR */);
    flowParseIntersectionType();
    while (tokenizer_1.eat(18948 /* bitwiseOR */)) {
        flowParseIntersectionType();
    }
}
function flowParseType() {
    flowParseUnionType();
}
function flowParseTypeAnnotation() {
    flowParseTypeInitialiser();
}
exports.flowParseTypeAnnotation = flowParseTypeAnnotation;
function flowParseTypeAnnotatableIdentifier() {
    expression_1.parseIdentifier();
    if (tokenizer_1.match(8192 /* colon */)) {
        flowParseTypeAnnotation();
    }
}
function flowParseVariance() {
    if (tokenizer_1.match(23178 /* plus */) || tokenizer_1.match(23690 /* minus */)) {
        tokenizer_1.next();
    }
}
exports.flowParseVariance = flowParseVariance;
// ==================================
// Overrides
// ==================================
function flowParseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody = null, funcContextId) {
    // For arrow functions, `parseArrow` handles the return type itself.
    if (!allowExpressionBody && tokenizer_1.match(8192 /* colon */)) {
        flowParseTypeAndPredicateInitialiser();
    }
    expression_1.parseFunctionBody(functionStart, isGenerator, allowExpressionBody, funcContextId);
}
exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;
// interfaces
function flowTryParseStatement() {
    if (tokenizer_1.match(2048 /* name */) && base_1.state.contextualKeyword === 15 /* _interface */) {
        tokenizer_1.runInTypeContext(0, () => {
            tokenizer_1.next();
            flowParseInterface();
        });
        return true;
    }
    else {
        return false;
    }
}
exports.flowTryParseStatement = flowTryParseStatement;
// declares, interfaces and type aliases
function flowParseIdentifierStatement(contextualKeyword) {
    if (contextualKeyword === 7 /* _declare */) {
        if (tokenizer_1.match(41488 /* _class */) ||
            tokenizer_1.match(2048 /* name */) ||
            tokenizer_1.match(34320 /* _function */) ||
            tokenizer_1.match(37392 /* _var */) ||
            tokenizer_1.match(42512 /* _export */)) {
            tokenizer_1.runInTypeContext(1, () => {
                flowParseDeclare();
            });
        }
    }
    else if (tokenizer_1.match(2048 /* name */)) {
        if (contextualKeyword === 15 /* _interface */) {
            tokenizer_1.runInTypeContext(1, () => {
                flowParseInterface();
            });
        }
        else if (contextualKeyword === 30 /* _type */) {
            tokenizer_1.runInTypeContext(1, () => {
                flowParseTypeAlias();
            });
        }
        else if (contextualKeyword === 22 /* _opaque */) {
            tokenizer_1.runInTypeContext(1, () => {
                flowParseOpaqueType(false);
            });
        }
    }
    util_1.semicolon();
}
exports.flowParseIdentifierStatement = flowParseIdentifierStatement;
// export type
function flowShouldParseExportDeclaration() {
    return (util_1.isContextual(30 /* _type */) ||
        util_1.isContextual(15 /* _interface */) ||
        util_1.isContextual(22 /* _opaque */));
}
exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;
function flowShouldDisallowExportDefaultSpecifier() {
    return (tokenizer_1.match(2048 /* name */) &&
        (base_1.state.contextualKeyword === 30 /* _type */ ||
            base_1.state.contextualKeyword === 15 /* _interface */ ||
            base_1.state.contextualKeyword === 22 /* _opaque */));
}
exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;
function flowParseExportDeclaration() {
    if (util_1.isContextual(30 /* _type */)) {
        tokenizer_1.runInTypeContext(1, () => {
            tokenizer_1.next();
            if (tokenizer_1.match(4096 /* braceL */)) {
                // export type { foo, bar };
                statement_1.parseExportSpecifiers();
                statement_1.parseExportFrom();
            }
            else {
                // export type Foo = Bar;
                flowParseTypeAlias();
            }
        });
    }
    else if (util_1.isContextual(22 /* _opaque */)) {
        tokenizer_1.runInTypeContext(1, () => {
            tokenizer_1.next();
            // export opaque type Foo = Bar;
            flowParseOpaqueType(false);
        });
    }
    else if (util_1.isContextual(15 /* _interface */)) {
        tokenizer_1.runInTypeContext(1, () => {
            tokenizer_1.next();
            flowParseInterface();
        });
    }
    else {
        statement_1.parseStatement(true);
    }
}
exports.flowParseExportDeclaration = flowParseExportDeclaration;
function flowShouldParseExportStar() {
    return tokenizer_1.match(24587 /* star */) || (util_1.isContextual(30 /* _type */) && tokenizer_1.lookaheadType() === 24587 /* star */);
}
exports.flowShouldParseExportStar = flowShouldParseExportStar;
function flowParseExportStar() {
    if (util_1.eatContextual(30 /* _type */)) {
        tokenizer_1.runInTypeContext(2, () => {
            statement_1.baseParseExportStar();
        });
    }
    else {
        statement_1.baseParseExportStar();
    }
}
exports.flowParseExportStar = flowParseExportStar;
// parse a the super class type parameters and implements
function flowAfterParseClassSuper(hasSuper) {
    if (hasSuper && tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterInstantiation();
    }
    if (util_1.isContextual(13 /* _implements */)) {
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 54800 /* _implements */;
        tokenizer_1.runInTypeContext(0, () => {
            tokenizer_1.next();
            do {
                flowParseRestrictedIdentifier();
                if (tokenizer_1.match(21000 /* lessThan */)) {
                    flowParseTypeParameterInstantiation();
                }
            } while (tokenizer_1.eat(7168 /* comma */));
        });
    }
}
exports.flowAfterParseClassSuper = flowAfterParseClassSuper;
// parse type parameters for object method shorthand
function flowStartParseObjPropValue() {
    // method shorthand
    if (tokenizer_1.match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
        if (!tokenizer_1.match(6144 /* parenL */))
            util_1.unexpected();
    }
}
exports.flowStartParseObjPropValue = flowStartParseObjPropValue;
function flowParseAssignableListItemTypes() {
    tokenizer_1.runInTypeContext(0, () => {
        tokenizer_1.eat(9728 /* question */);
        if (tokenizer_1.match(8192 /* colon */)) {
            flowParseTypeAnnotation();
        }
    });
}
exports.flowParseAssignableListItemTypes = flowParseAssignableListItemTypes;
// parse typeof and type imports
function flowStartParseImportSpecifiers() {
    let kind = null;
    if (tokenizer_1.match(46736 /* _typeof */)) {
        kind = "typeof";
    }
    else if (util_1.isContextual(30 /* _type */)) {
        kind = "type";
    }
    if (kind) {
        const lh = tokenizer_1.lookaheadTypeAndKeyword();
        if (isMaybeDefaultImport(lh) || lh.type === 4096 /* braceL */ || lh.type === 24587 /* star */) {
            tokenizer_1.next();
        }
    }
}
exports.flowStartParseImportSpecifiers = flowStartParseImportSpecifiers;
// parse import-type/typeof shorthand
function flowParseImportSpecifier() {
    const isTypeKeyword = base_1.state.contextualKeyword === 30 /* _type */ || base_1.state.type === 46736 /* _typeof */;
    if (isTypeKeyword) {
        tokenizer_1.next();
    }
    else {
        expression_1.parseIdentifier();
    }
    if (util_1.isContextual(2 /* _as */) && !util_1.isLookaheadContextual(2 /* _as */)) {
        expression_1.parseIdentifier();
        if (isTypeKeyword && !tokenizer_1.match(2048 /* name */) && !(base_1.state.type & 16 /* IS_KEYWORD */)) {
            // `import {type as ,` or `import {type as }`
        }
        else {
            // `import {type as foo`
            expression_1.parseIdentifier();
        }
    }
    else if (isTypeKeyword && (tokenizer_1.match(2048 /* name */) || !!(base_1.state.type & 16 /* IS_KEYWORD */))) {
        // `import {type foo`
        expression_1.parseIdentifier();
        if (util_1.eatContextual(2 /* _as */)) {
            expression_1.parseIdentifier();
        }
    }
}
exports.flowParseImportSpecifier = flowParseImportSpecifier;
// parse function type parameters - function foo<T>() {}
function flowStartParseFunctionParams() {
    // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
    // anyway, so don't try to propagate that information.
    if (tokenizer_1.match(21000 /* lessThan */)) {
        tokenizer_1.runInTypeContext(0, () => {
            flowParseTypeParameterDeclaration();
        });
    }
}
exports.flowStartParseFunctionParams = flowStartParseFunctionParams;
// parse flow type annotations on variable declarator heads - let foo: string = bar
function flowAfterParseVarHead() {
    if (tokenizer_1.match(8192 /* colon */)) {
        flowParseTypeAnnotation();
    }
}
exports.flowAfterParseVarHead = flowAfterParseVarHead;
// parse the return type of an async arrow function - let foo = (async (): number => {});
function flowStartParseAsyncArrowFromCallExpression() {
    if (tokenizer_1.match(8192 /* colon */)) {
        const oldNoAnonFunctionType = base_1.state.noAnonFunctionType;
        base_1.state.noAnonFunctionType = true;
        flowParseTypeAnnotation();
        base_1.state.noAnonFunctionType = oldNoAnonFunctionType;
    }
}
exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;
// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
function flowParseMaybeAssign(noIn, afterLeftParse) {
    let jsxError = null;
    if (tokenizer_1.match(21000 /* lessThan */)) {
        const snapshot = base_1.state.snapshot();
        try {
            return expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                base_1.state.restoreFromSnapshot(snapshot);
                base_1.state.type = 28160 /* typeParameterStart */;
                jsxError = err;
            }
            else {
                // istanbul ignore next: no such error is expected
                throw err;
            }
        }
    }
    if (jsxError != null || tokenizer_1.match(21000 /* lessThan */)) {
        let wasArrow = false;
        try {
            tokenizer_1.runInTypeContext(0, () => {
                flowParseTypeParameterDeclaration();
            });
            wasArrow = expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
        }
        catch (err) {
            throw jsxError || err;
        }
        if (wasArrow) {
            return true;
        }
        util_1.unexpected();
    }
    return expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
}
exports.flowParseMaybeAssign = flowParseMaybeAssign;
// handle return types for arrow functions
function flowParseArrow() {
    if (tokenizer_1.match(8192 /* colon */)) {
        tokenizer_1.runInTypeContext(0, () => {
            const snapshot = base_1.state.snapshot();
            try {
                const oldNoAnonFunctionType = base_1.state.noAnonFunctionType;
                base_1.state.noAnonFunctionType = true;
                flowParseTypeAndPredicateInitialiser();
                base_1.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (util_1.canInsertSemicolon())
                    util_1.unexpected();
                if (!tokenizer_1.match(10752 /* arrow */))
                    util_1.unexpected();
            }
            catch (err) {
                if (err instanceof SyntaxError) {
                    base_1.state.restoreFromSnapshot(snapshot);
                }
                else {
                    // istanbul ignore next: no such error is expected
                    throw err;
                }
            }
        });
    }
    return tokenizer_1.eat(10752 /* arrow */);
}
exports.flowParseArrow = flowParseArrow;
function flowParseSubscripts(startPos, noCalls) {
    if (base_1.state.tokens[base_1.state.tokens.length - 1].contextualKeyword === 3 /* _async */ &&
        tokenizer_1.match(21000 /* lessThan */)) {
        const snapshot = base_1.state.snapshot();
        let error;
        try {
            const wasArrow = parseAsyncArrowWithTypeParameters(startPos);
            if (wasArrow) {
                return;
            }
        }
        catch (e) {
            error = e;
        }
        base_1.state.restoreFromSnapshot(snapshot);
        try {
            expression_1.baseParseSubscripts(startPos, noCalls);
            return;
        }
        catch (e) {
            throw error || e;
        }
    }
    expression_1.baseParseSubscripts(startPos, noCalls);
}
exports.flowParseSubscripts = flowParseSubscripts;
// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters(startPos) {
    const startTokenIndex = base_1.state.tokens.length;
    statement_1.parseFunctionParams();
    if (!expression_1.parseArrow()) {
        return false;
    }
    expression_1.parseArrowExpression(startPos, startTokenIndex);
    return true;
}
