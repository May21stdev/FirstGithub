import { hasPlugin, state } from "../parser/base";
import { atPossibleAsync, baseParseMaybeAssign, baseParseSubscript, parseCallExpressionArguments, parseExprAtom, parseExpression, parseFunctionBody, parseIdentifier, parseLiteral, parseMaybeAssign, parseMaybeUnary, parsePropertyName, } from "../parser/expression";
import { parseBindingList } from "../parser/lval";
import { parseBlockBody, parseClass, parseClassProperty, parseClassPropertyName, parseFunction, parseFunctionParams, parsePostMemberNameModifiers, parseStatement, parseVarStatement, } from "../parser/statement";
import { canInsertSemicolon, eatContextual, expect, expectContextual, hasPrecedingLineBreak, isContextual, isLineTerminator, isLookaheadContextual, semicolon, unexpected, } from "../parser/util";
import { eat, lookaheadType, lookaheadTypeAndKeyword, match, next, runInTypeContext, } from "../tokenizer";
function assert(x) {
    if (!x) {
        throw new Error("Assert fail");
    }
}
function tsIsIdentifier() {
    // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
    // See https://github.com/Microsoft/TypeScript/issues/15008
    return match(2048 /* name */);
}
function tsNextTokenCanFollowModifier() {
    // Note: TypeScript's implementation is much more complicated because
    // more things are considered modifiers there.
    // This implementation only handles modifiers not handled by babylon itself. And "static".
    // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
    next();
    return (!hasPrecedingLineBreak() &&
        !match(6144 /* parenL */) &&
        !match(8192 /* colon */) &&
        !match(14368 /* eq */) &&
        !match(9728 /* question */));
}
/** Parses a modifier matching one the given modifier names. */
export function tsParseModifier(allowedModifiers) {
    if (!match(2048 /* name */)) {
        return null;
    }
    const modifier = state.contextualKeyword;
    if (allowedModifiers.indexOf(modifier) !== -1 &&
        tsTryParse(() => tsNextTokenCanFollowModifier())) {
        switch (modifier) {
            case 26 /* _readonly */:
                state.tokens[state.tokens.length - 1].type = 50192 /* _readonly */;
                break;
            case 1 /* _abstract */:
                state.tokens[state.tokens.length - 1].type = 50704 /* _abstract */;
                break;
            case 29 /* _static */:
                state.tokens[state.tokens.length - 1].type = 51216 /* _static */;
                break;
            case 25 /* _public */:
                state.tokens[state.tokens.length - 1].type = 51728 /* _public */;
                break;
            case 23 /* _private */:
                state.tokens[state.tokens.length - 1].type = 52240 /* _private */;
                break;
            case 24 /* _protected */:
                state.tokens[state.tokens.length - 1].type = 52752 /* _protected */;
                break;
            default:
                break;
        }
        return modifier;
    }
    return null;
}
function tsIsListTerminator(kind) {
    switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
            return match(5120 /* braceR */);
        case "HeritageClauseElement":
            return match(4096 /* braceL */);
        case "TupleElementTypes":
            return match(3584 /* bracketR */);
        case "TypeParametersOrArguments":
            return match(21512 /* greaterThan */);
        default:
            break;
    }
    throw new Error("Unreachable");
}
function tsParseList(kind, parseElement) {
    while (!tsIsListTerminator(kind)) {
        // Skipping "parseListElement" from the TS source since that's just for error handling.
        parseElement();
    }
}
function tsParseDelimitedList(kind, parseElement) {
    tsParseDelimitedListWorker(kind, parseElement);
}
/**
 * If !expectSuccess, returns undefined instead of failing to parse.
 * If expectSuccess, parseElement should always return a defined value.
 */
function tsParseDelimitedListWorker(kind, parseElement) {
    while (true) {
        if (tsIsListTerminator(kind)) {
            break;
        }
        parseElement();
        if (eat(7168 /* comma */)) {
            continue;
        }
        if (tsIsListTerminator(kind)) {
            break;
        }
    }
}
function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
    if (!skipFirstToken) {
        if (bracket) {
            expect(3072 /* bracketL */);
        }
        else {
            expect(21000 /* lessThan */);
        }
    }
    tsParseDelimitedList(kind, parseElement);
    if (bracket) {
        expect(3584 /* bracketR */);
    }
    else {
        expect(21512 /* greaterThan */);
    }
}
function tsParseEntityName() {
    parseIdentifier();
    while (eat(9216 /* dot */)) {
        parseIdentifier();
    }
}
function tsParseTypeReference() {
    tsParseEntityName();
    if (!hasPrecedingLineBreak() && match(21000 /* lessThan */)) {
        tsParseTypeArguments();
    }
}
function tsParseThisTypePredicate() {
    next();
    tsParseTypeAnnotation();
}
function tsParseThisTypeNode() {
    next();
}
function tsParseTypeQuery() {
    expect(46736 /* _typeof */);
    tsParseEntityName();
}
function tsParseTypeParameter() {
    parseIdentifier();
    if (eat(42000 /* _extends */)) {
        tsParseType();
    }
    if (eat(14368 /* eq */)) {
        tsParseType();
    }
}
export function tsTryParseTypeParameters() {
    if (match(21000 /* lessThan */)) {
        tsParseTypeParameters();
    }
}
function tsParseTypeParameters() {
    runInTypeContext(0, () => {
        if (match(21000 /* lessThan */) || match(28160 /* typeParameterStart */)) {
            next();
        }
        else {
            unexpected();
        }
        tsParseBracketedList("TypeParametersOrArguments", tsParseTypeParameter, 
        /* bracket */ false, 
        /* skipFirstToken */ true);
    });
}
// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
// but here it's always false, because this is only used for types.
function tsFillSignature(returnToken) {
    // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
    const returnTokenRequired = returnToken === 10752 /* arrow */;
    tsTryParseTypeParameters();
    expect(6144 /* parenL */);
    tsParseBindingListForSignature(false /* isBlockScope */);
    if (returnTokenRequired) {
        tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
    else if (match(returnToken)) {
        tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
}
function tsParseBindingListForSignature(isBlockScope) {
    parseBindingList(6656 /* parenR */, isBlockScope);
}
function tsParseTypeMemberSemicolon() {
    if (!eat(7168 /* comma */)) {
        semicolon();
    }
}
function tsParseSignatureMember(kind) {
    if (kind === "TSConstructSignatureDeclaration") {
        expect(39952 /* _new */);
    }
    tsFillSignature(8192 /* colon */);
    tsParseTypeMemberSemicolon();
}
function tsIsUnambiguouslyIndexSignature() {
    next(); // Skip '{'
    return eat(2048 /* name */) && match(8192 /* colon */);
}
function tsTryParseIndexSignature() {
    if (!(match(3072 /* bracketL */) && tsLookAhead(tsIsUnambiguouslyIndexSignature))) {
        return false;
    }
    expect(3072 /* bracketL */);
    parseIdentifier();
    tsParseTypeAnnotation();
    expect(3584 /* bracketR */);
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
    return true;
}
function tsParsePropertyOrMethodSignature(readonly) {
    parsePropertyName(-1 /* Types don't need context IDs. */);
    eat(9728 /* question */);
    if (!readonly && (match(6144 /* parenL */) || match(21000 /* lessThan */))) {
        tsFillSignature(8192 /* colon */);
        tsParseTypeMemberSemicolon();
    }
    else {
        tsTryParseTypeAnnotation();
        tsParseTypeMemberSemicolon();
    }
}
function tsParseTypeMember() {
    if (match(6144 /* parenL */) || match(21000 /* lessThan */)) {
        tsParseSignatureMember("TSCallSignatureDeclaration");
        return;
    }
    if (match(39952 /* _new */) && tsLookAhead(tsIsStartOfConstructSignature)) {
        tsParseSignatureMember("TSConstructSignatureDeclaration");
        return;
    }
    const readonly = !!tsParseModifier([26 /* _readonly */]);
    const found = tsTryParseIndexSignature();
    if (found) {
        return;
    }
    tsParsePropertyOrMethodSignature(readonly);
}
function tsIsStartOfConstructSignature() {
    next();
    return match(6144 /* parenL */) || match(21000 /* lessThan */);
}
function tsParseTypeLiteral() {
    tsParseObjectTypeMembers();
}
function tsParseObjectTypeMembers() {
    expect(4096 /* braceL */);
    tsParseList("TypeMembers", tsParseTypeMember);
    expect(5120 /* braceR */);
}
function tsIsStartOfMappedType() {
    next();
    if (eat(23178 /* plus */) || eat(23690 /* minus */)) {
        return isContextual(26 /* _readonly */);
    }
    if (isContextual(26 /* _readonly */)) {
        next();
    }
    if (!match(3072 /* bracketL */)) {
        return false;
    }
    next();
    if (!tsIsIdentifier()) {
        return false;
    }
    next();
    return match(45592 /* _in */);
}
function tsParseMappedTypeParameter() {
    parseIdentifier();
    expect(45592 /* _in */);
    tsParseType();
}
function tsParseMappedType() {
    expect(4096 /* braceL */);
    if (match(23178 /* plus */) || match(23690 /* minus */)) {
        next();
        expectContextual(26 /* _readonly */);
    }
    else {
        eatContextual(26 /* _readonly */);
    }
    expect(3072 /* bracketL */);
    tsParseMappedTypeParameter();
    expect(3584 /* bracketR */);
    if (match(23178 /* plus */) || match(23690 /* minus */)) {
        next();
        expect(9728 /* question */);
    }
    else {
        eat(9728 /* question */);
    }
    tsTryParseType();
    semicolon();
    expect(5120 /* braceR */);
}
function tsParseTupleType() {
    tsParseBracketedList("TupleElementTypes", tsParseType, 
    /* bracket */ true, 
    /* skipFirstToken */ false);
}
function tsParseParenthesizedType() {
    expect(6144 /* parenL */);
    tsParseType();
    expect(6656 /* parenR */);
}
function tsParseFunctionOrConstructorType(type) {
    if (type === "TSConstructorType") {
        expect(39952 /* _new */);
    }
    tsFillSignature(10752 /* arrow */);
}
function tsParseNonArrayType() {
    switch (state.type) {
        case 2048 /* name */:
            tsParseTypeReference();
            return;
        case 47248 /* _void */:
        case 44048 /* _null */:
            next();
            return;
        case 1536 /* string */:
        case 0 /* num */:
        case 44560 /* _true */:
        case 45072 /* _false */:
            parseLiteral();
            return;
        case 23690 /* minus */:
            next();
            parseLiteral();
            return;
        case 40464 /* _this */: {
            tsParseThisTypeNode();
            if (isContextual(16 /* _is */) && !hasPrecedingLineBreak()) {
                tsParseThisTypePredicate();
            }
            return;
        }
        case 46736 /* _typeof */:
            tsParseTypeQuery();
            return;
        case 4096 /* braceL */:
            if (tsLookAhead(tsIsStartOfMappedType)) {
                tsParseMappedType();
            }
            else {
                tsParseTypeLiteral();
            }
            return;
        case 3072 /* bracketL */:
            tsParseTupleType();
            return;
        case 6144 /* parenL */:
            tsParseParenthesizedType();
            return;
        default:
            break;
    }
    throw unexpected();
}
function tsParseArrayTypeOrHigher() {
    tsParseNonArrayType();
    while (!hasPrecedingLineBreak() && eat(3072 /* bracketL */)) {
        if (!eat(3584 /* bracketR */)) {
            // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
            tsParseType();
            expect(3584 /* bracketR */);
        }
    }
}
function tsParseInferType() {
    expectContextual(14 /* _infer */);
    parseIdentifier();
}
function tsParseTypeOperatorOrHigher() {
    if (isContextual(17 /* _keyof */) || isContextual(31 /* _unique */)) {
        next();
        tsParseTypeOperatorOrHigher();
    }
    else if (isContextual(14 /* _infer */)) {
        tsParseInferType();
    }
    else {
        tsParseArrayTypeOrHigher();
    }
}
function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
    eat(operator);
    parseConstituentType();
    if (match(operator)) {
        while (eat(operator)) {
            parseConstituentType();
        }
    }
}
function tsParseIntersectionTypeOrHigher() {
    tsParseUnionOrIntersectionType("TSIntersectionType", tsParseTypeOperatorOrHigher, 19974 /* bitwiseAND */);
}
function tsParseUnionTypeOrHigher() {
    tsParseUnionOrIntersectionType("TSUnionType", tsParseIntersectionTypeOrHigher, 18948 /* bitwiseOR */);
}
function tsIsStartOfFunctionType() {
    if (match(21000 /* lessThan */)) {
        return true;
    }
    return match(6144 /* parenL */) && tsLookAhead(tsIsUnambiguouslyStartOfFunctionType);
}
function tsSkipParameterStart() {
    if (match(2048 /* name */) || match(40464 /* _this */)) {
        next();
        return true;
    }
    return false;
}
function tsIsUnambiguouslyStartOfFunctionType() {
    next();
    if (match(6656 /* parenR */) || match(11776 /* ellipsis */)) {
        // ( )
        // ( ...
        return true;
    }
    if (tsSkipParameterStart()) {
        if (match(8192 /* colon */) || match(7168 /* comma */) || match(9728 /* question */) || match(14368 /* eq */)) {
            // ( xxx :
            // ( xxx ,
            // ( xxx ?
            // ( xxx =
            return true;
        }
        if (match(6656 /* parenR */)) {
            next();
            if (match(10752 /* arrow */)) {
                // ( xxx ) =>
                return true;
            }
        }
    }
    return false;
}
function tsParseTypeOrTypePredicateAnnotation(returnToken) {
    runInTypeContext(0, () => {
        expect(returnToken);
        tsTryParse(() => tsParseTypePredicatePrefix());
        // Regardless of whether we found an "is" token, there's now just a regular type in front of
        // us.
        tsParseType();
    });
}
function tsTryParseTypeOrTypePredicateAnnotation() {
    if (match(8192 /* colon */)) {
        tsParseTypeOrTypePredicateAnnotation(8192 /* colon */);
    }
}
export function tsTryParseTypeAnnotation() {
    if (match(8192 /* colon */)) {
        tsParseTypeAnnotation();
    }
}
function tsTryParseType() {
    if (eat(8192 /* colon */)) {
        tsParseType();
    }
}
function tsParseTypePredicatePrefix() {
    parseIdentifier();
    if (isContextual(16 /* _is */) && !hasPrecedingLineBreak()) {
        next();
        return true;
    }
    return false;
}
export function tsParseTypeAnnotation() {
    runInTypeContext(0, () => {
        expect(8192 /* colon */);
        tsParseType();
    });
}
export function tsParseType() {
    tsParseNonConditionalType();
    if (hasPrecedingLineBreak() || !eat(42000 /* _extends */)) {
        return;
    }
    // extends type
    tsParseNonConditionalType();
    expect(9728 /* question */);
    // true type
    tsParseType();
    expect(8192 /* colon */);
    // false type
    tsParseType();
}
export function tsParseNonConditionalType() {
    if (tsIsStartOfFunctionType()) {
        tsParseFunctionOrConstructorType("TSFunctionType");
        return;
    }
    if (match(39952 /* _new */)) {
        // As in `new () => Date`
        tsParseFunctionOrConstructorType("TSConstructorType");
        return;
    }
    tsParseUnionTypeOrHigher();
}
export function tsParseTypeAssertion() {
    runInTypeContext(1, () => {
        tsParseType();
        expect(21512 /* greaterThan */);
    });
    parseMaybeUnary();
}
// Returns true if parsing was successful.
function tsTryParseTypeArgumentsInExpression() {
    return tsTryParseAndCatch(() => {
        runInTypeContext(0, () => {
            expect(21000 /* lessThan */);
            state.tokens[state.tokens.length - 1].type = 28160 /* typeParameterStart */;
            tsParseDelimitedList("TypeParametersOrArguments", tsParseType);
            expect(21512 /* greaterThan */);
        });
        expect(6144 /* parenL */);
    });
}
function tsParseHeritageClause() {
    tsParseDelimitedList("HeritageClauseElement", tsParseExpressionWithTypeArguments);
}
function tsParseExpressionWithTypeArguments() {
    // Note: TS uses parseLeftHandSideExpressionOrHigher,
    // then has grammar errors later if it's not an EntityName.
    tsParseEntityName();
    if (match(21000 /* lessThan */)) {
        tsParseTypeArguments();
    }
}
function tsParseInterfaceDeclaration() {
    parseIdentifier();
    tsTryParseTypeParameters();
    if (eat(42000 /* _extends */)) {
        tsParseHeritageClause();
    }
    tsParseObjectTypeMembers();
}
function tsParseTypeAliasDeclaration() {
    parseIdentifier();
    tsTryParseTypeParameters();
    expect(14368 /* eq */);
    tsParseType();
    semicolon();
}
function tsParseEnumMember() {
    // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
    if (match(1536 /* string */)) {
        parseLiteral();
    }
    else {
        parseIdentifier();
    }
    if (eat(14368 /* eq */)) {
        const eqIndex = state.tokens.length - 1;
        parseMaybeAssign();
        state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
    }
}
function tsParseEnumDeclaration() {
    parseIdentifier();
    expect(4096 /* braceL */);
    tsParseDelimitedList("EnumMembers", tsParseEnumMember);
    expect(5120 /* braceR */);
}
function tsParseModuleBlock() {
    expect(4096 /* braceL */);
    // Inside of a module block is considered "top-level", meaning it can have imports and exports.
    parseBlockBody(/* topLevel */ true, /* end */ 5120 /* braceR */);
}
function tsParseModuleOrNamespaceDeclaration() {
    parseIdentifier();
    if (eat(9216 /* dot */)) {
        tsParseModuleOrNamespaceDeclaration();
    }
    else {
        tsParseModuleBlock();
    }
}
function tsParseAmbientExternalModuleDeclaration() {
    if (isContextual(12 /* _global */)) {
        parseIdentifier();
    }
    else if (match(1536 /* string */)) {
        parseExprAtom();
    }
    else {
        unexpected();
    }
    if (match(4096 /* braceL */)) {
        tsParseModuleBlock();
    }
    else {
        semicolon();
    }
}
export function tsParseImportEqualsDeclaration() {
    parseIdentifier();
    expect(14368 /* eq */);
    tsParseModuleReference();
    semicolon();
}
function tsIsExternalModuleReference() {
    return isContextual(27 /* _require */) && lookaheadType() === 6144 /* parenL */;
}
function tsParseModuleReference() {
    if (tsIsExternalModuleReference()) {
        tsParseExternalModuleReference();
    }
    else {
        tsParseEntityName();
    }
}
function tsParseExternalModuleReference() {
    expectContextual(27 /* _require */);
    expect(6144 /* parenL */);
    if (!match(1536 /* string */)) {
        throw unexpected();
    }
    parseLiteral();
    expect(6656 /* parenR */);
}
// Utilities
function tsLookAhead(f) {
    const snapshot = state.snapshot();
    const res = f();
    state.restoreFromSnapshot(snapshot);
    return res;
}
// Returns true if parsing was successful.
function tsTryParseAndCatch(f) {
    const snapshot = state.snapshot();
    try {
        f();
        return true;
    }
    catch (e) {
        if (e instanceof SyntaxError) {
            state.restoreFromSnapshot(snapshot);
            return false;
        }
        throw e;
    }
}
// The function should return true if the parse was successful. If not, we revert the state to
// before we started parsing.
function tsTryParse(f) {
    const snapshot = state.snapshot();
    const wasSuccessful = f();
    if (wasSuccessful) {
        return true;
    }
    else {
        state.restoreFromSnapshot(snapshot);
        return false;
    }
}
// Returns true if a statement matched.
function tsTryParseDeclare() {
    switch (state.type) {
        case 34320 /* _function */:
            runInTypeContext(1, () => {
                next();
                // We don't need to precisely get the function start here, since it's only used to mark
                // the function as a type if it's bodiless, and it's already a type here.
                const functionStart = state.start;
                parseFunction(functionStart, /* isStatement */ true);
            });
            return true;
        case 41488 /* _class */:
            runInTypeContext(1, () => {
                parseClass(/* isStatement */ true, /* optionalId */ false);
            });
            return true;
        case 38416 /* _const */:
            if (match(38416 /* _const */) && isLookaheadContextual(8 /* _enum */)) {
                runInTypeContext(1, () => {
                    // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
                    expect(38416 /* _const */);
                    expectContextual(8 /* _enum */);
                    state.tokens[state.tokens.length - 1].type = 53776 /* _enum */;
                    tsParseEnumDeclaration();
                });
                return true;
            }
        // falls through
        case 37392 /* _var */:
        case 37904 /* _let */:
            runInTypeContext(1, () => {
                parseVarStatement(state.type);
            });
            return true;
        case 2048 /* name */: {
            return runInTypeContext(1, () => {
                const contextualKeyword = state.contextualKeyword;
                if (contextualKeyword === 12 /* _global */) {
                    tsParseAmbientExternalModuleDeclaration();
                    return true;
                }
                else {
                    return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);
                }
            });
        }
        default:
            return false;
    }
}
// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.
function tsTryParseExportDeclaration() {
    return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);
}
// Returns true if it matched a statement.
function tsParseExpressionStatement(contextualKeyword) {
    switch (contextualKeyword) {
        case 7 /* _declare */: {
            const declareTokenIndex = state.tokens.length - 1;
            const matched = tsTryParseDeclare();
            if (matched) {
                state.tokens[declareTokenIndex].type = 49680 /* _declare */;
                return true;
            }
            break;
        }
        case 12 /* _global */:
            // `global { }` (with no `declare`) may appear inside an ambient module declaration.
            // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
            if (match(4096 /* braceL */)) {
                tsParseModuleBlock();
                return true;
            }
            break;
        default:
            return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);
    }
    return false;
}
// Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
// Returns true if it matched a declaration.
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
    switch (contextualKeyword) {
        case 1 /* _abstract */:
            if (isBeforeToken || match(41488 /* _class */)) {
                if (isBeforeToken)
                    next();
                state.tokens[state.tokens.length - 1].type = 50704 /* _abstract */;
                parseClass(/* isStatement */ true, /* optionalId */ false);
                return true;
            }
            break;
        case 8 /* _enum */:
            if (isBeforeToken || match(2048 /* name */)) {
                if (isBeforeToken)
                    next();
                state.tokens[state.tokens.length - 1].type = 53776 /* _enum */;
                tsParseEnumDeclaration();
                return true;
            }
            break;
        case 15 /* _interface */:
            if (isBeforeToken || match(2048 /* name */)) {
                // `next` is true in "export" and "declare" contexts, so we want to remove that token
                // as well.
                runInTypeContext(1, () => {
                    if (isBeforeToken)
                        next();
                    tsParseInterfaceDeclaration();
                });
                return true;
            }
            break;
        case 19 /* _module */:
            if (isBeforeToken)
                next();
            if (match(1536 /* string */)) {
                runInTypeContext(isBeforeToken ? 2 : 1, () => {
                    tsParseAmbientExternalModuleDeclaration();
                });
                return true;
            }
            else if (next || match(2048 /* name */)) {
                runInTypeContext(isBeforeToken ? 2 : 1, () => {
                    tsParseModuleOrNamespaceDeclaration();
                });
                return true;
            }
            break;
        case 20 /* _namespace */:
            if (isBeforeToken || match(2048 /* name */)) {
                runInTypeContext(1, () => {
                    if (isBeforeToken)
                        next();
                    tsParseModuleOrNamespaceDeclaration();
                });
                return true;
            }
            break;
        case 30 /* _type */:
            if (isBeforeToken || match(2048 /* name */)) {
                runInTypeContext(1, () => {
                    if (isBeforeToken)
                        next();
                    tsParseTypeAliasDeclaration();
                });
                return true;
            }
            break;
        default:
            break;
    }
    return false;
}
// Returns true if there was a generic async arrow function.
function tsTryParseGenericAsyncArrowFunction() {
    const matched = tsTryParseAndCatch(() => {
        tsParseTypeParameters();
        parseFunctionParams();
        tsTryParseTypeOrTypePredicateAnnotation();
        expect(10752 /* arrow */);
    });
    if (!matched) {
        return false;
    }
    // We don't need to be precise about the function start since it's only used if this is a
    // bodiless function, which isn't valid here.
    const functionStart = state.start;
    parseFunctionBody(functionStart, false /* isGenerator */, true);
    return true;
}
function tsParseTypeArguments() {
    runInTypeContext(0, () => {
        expect(21000 /* lessThan */);
        tsParseDelimitedList("TypeParametersOrArguments", tsParseType);
        expect(21512 /* greaterThan */);
    });
}
export function tsIsDeclarationStart() {
    if (match(2048 /* name */)) {
        switch (state.contextualKeyword) {
            case 1 /* _abstract */:
            case 7 /* _declare */:
            case 8 /* _enum */:
            case 15 /* _interface */:
            case 19 /* _module */:
            case 20 /* _namespace */:
            case 30 /* _type */:
                return true;
            default:
                break;
        }
    }
    return false;
}
// ======================================================
// OVERRIDES
// ======================================================
export function tsParseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody = null, funcContextId) {
    // For arrow functions, `parseArrow` handles the return type itself.
    if (!allowExpressionBody && match(8192 /* colon */)) {
        tsParseTypeOrTypePredicateAnnotation(8192 /* colon */);
    }
    // The original code checked the node type to make sure this function type allows a missing
    // body, but we skip that to avoid sending around the node type. We instead just use the
    // allowExpressionBody boolean to make sure it's not an arrow function.
    if (!allowExpressionBody && !match(4096 /* braceL */) && isLineTerminator()) {
        // Retroactively mark the function declaration as a type.
        let i = state.tokens.length - 1;
        while (i >= 0 &&
            (state.tokens[i].start >= functionStart ||
                state.tokens[i].type === 31760 /* _default */ ||
                state.tokens[i].type === 42512 /* _export */)) {
            state.tokens[i].isType = true;
            i--;
        }
        return;
    }
    parseFunctionBody(functionStart, isGenerator, allowExpressionBody, funcContextId);
}
export function tsParseSubscript(startPos, noCalls, stopState) {
    if (!hasPrecedingLineBreak() && eat(16000 /* bang */)) {
        state.tokens[state.tokens.length - 1].type = 28672 /* nonNullAssertion */;
        return;
    }
    if (!noCalls && match(21000 /* lessThan */)) {
        if (atPossibleAsync()) {
            // Almost certainly this is a generic async function `async <T>() => ...
            // But it might be a call with a type argument `async<T>();`
            const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
            if (asyncArrowFn) {
                return;
            }
        }
        // May be passing type arguments. But may just be the `<` operator.
        const typeArguments = tsTryParseTypeArgumentsInExpression(); // Also eats the "("
        if (typeArguments) {
            // possibleAsync always false here, because we would have handled it above.
            parseCallExpressionArguments(6656 /* parenR */);
        }
    }
    baseParseSubscript(startPos, noCalls, stopState);
}
export function tsStartParseNewArguments() {
    if (match(21000 /* lessThan */)) {
        // tsTryParseAndCatch is expensive, so avoid if not necessary.
        // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.
        tsTryParseAndCatch(() => {
            state.type = 28160 /* typeParameterStart */;
            tsParseTypeArguments();
            if (!match(6144 /* parenL */)) {
                unexpected();
            }
        });
    }
}
export function tsTryParseExport() {
    if (match(43024 /* _import */)) {
        // `export import A = B;`
        expect(43024 /* _import */);
        tsParseImportEqualsDeclaration();
        return true;
    }
    else if (eat(14368 /* eq */)) {
        // `export = x;`
        parseExpression();
        semicolon();
        return true;
    }
    else if (eatContextual(2 /* _as */)) {
        // `export as namespace A;`
        // See `parseNamespaceExportDeclaration` in TypeScript's own parser
        expectContextual(20 /* _namespace */);
        parseIdentifier();
        semicolon();
        return true;
    }
    else {
        return false;
    }
}
export function tsTryParseExportDefaultExpression() {
    if (isContextual(1 /* _abstract */) && lookaheadType() === 41488 /* _class */) {
        state.type = 50704 /* _abstract */;
        next(); // Skip "abstract"
        parseClass(true, true);
        return true;
    }
    return false;
}
export function tsTryParseStatementContent() {
    if (state.type === 38416 /* _const */) {
        const ahead = lookaheadTypeAndKeyword();
        if (ahead.type === 2048 /* name */ && ahead.contextualKeyword === 8 /* _enum */) {
            expect(38416 /* _const */);
            expectContextual(8 /* _enum */);
            state.tokens[state.tokens.length - 1].type = 53776 /* _enum */;
            tsParseEnumDeclaration();
            return true;
        }
    }
    return false;
}
export function tsParseAccessModifier() {
    tsParseModifier([
        25 /* _public */,
        24 /* _protected */,
        23 /* _private */,
    ]);
}
export function tsTryParseClassMemberWithIsStatic(isStatic, classContextId) {
    let isAbstract = false;
    let isReadonly = false;
    const mod = tsParseModifier([1 /* _abstract */, 26 /* _readonly */]);
    switch (mod) {
        case 26 /* _readonly */:
            isReadonly = true;
            isAbstract = !!tsParseModifier([1 /* _abstract */]);
            break;
        case 1 /* _abstract */:
            isAbstract = true;
            isReadonly = !!tsParseModifier([26 /* _readonly */]);
            break;
        default:
            break;
    }
    // We no longer check for public/private/etc, but tsTryParseIndexSignature should just return
    // false in that case for valid code.
    if (!isAbstract && !isStatic) {
        const found = tsTryParseIndexSignature();
        if (found) {
            return true;
        }
    }
    if (isReadonly) {
        // Must be a property (if not an index signature).
        parseClassPropertyName(classContextId);
        parsePostMemberNameModifiers();
        parseClassProperty();
        return true;
    }
    return false;
}
// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
// is that e.g. `type()` is valid JS, so we must try parsing that first.
// If it's really a type, we will parse `type` as the statement, and can correct it here
// by parsing the rest.
export function tsParseIdentifierStatement(contextualKeyword) {
    const matched = tsParseExpressionStatement(contextualKeyword);
    if (!matched) {
        semicolon();
    }
}
export function tsParseExportDeclaration() {
    // "export declare" is equivalent to just "export".
    const isDeclare = eatContextual(7 /* _declare */);
    if (isDeclare) {
        state.tokens[state.tokens.length - 1].type = 49680 /* _declare */;
    }
    let matchedDeclaration = false;
    if (match(2048 /* name */)) {
        if (isDeclare) {
            matchedDeclaration = runInTypeContext(2, () => tsTryParseExportDeclaration());
        }
        else {
            matchedDeclaration = tsTryParseExportDeclaration();
        }
    }
    if (!matchedDeclaration) {
        if (isDeclare) {
            runInTypeContext(2, () => {
                parseStatement(true);
            });
        }
        else {
            parseStatement(true);
        }
    }
}
export function tsAfterParseClassSuper(hasSuper) {
    if (hasSuper && match(21000 /* lessThan */)) {
        tsParseTypeArguments();
    }
    if (eatContextual(13 /* _implements */)) {
        state.tokens[state.tokens.length - 1].type = 54800 /* _implements */;
        runInTypeContext(1, () => {
            tsParseHeritageClause();
        });
    }
}
export function tsStartParseObjPropValue() {
    if (match(21000 /* lessThan */)) {
        throw new Error("TODO");
    }
}
export function tsStartParseFunctionParams() {
    tsTryParseTypeParameters();
}
// `let x: number;`
export function tsAfterParseVarHead() {
    eat(16000 /* bang */);
    tsTryParseTypeAnnotation();
}
// parse the return type of an async arrow function - let foo = (async (): number => {});
export function tsStartParseAsyncArrowFromCallExpression() {
    if (match(8192 /* colon */)) {
        tsParseTypeAnnotation();
    }
}
// Returns true if the expression was an arrow function.
export function tsParseMaybeAssign(noIn = null, afterLeftParse) {
    // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
    let jsxError = null;
    if (match(21000 /* lessThan */) && hasPlugin("jsx")) {
        // Prefer to parse JSX if possible. But may be an arrow fn.
        const snapshot = state.snapshot();
        try {
            return baseParseMaybeAssign(noIn, afterLeftParse);
        }
        catch (err) {
            if (!(err instanceof SyntaxError)) {
                // istanbul ignore next: no such error is expected
                throw err;
            }
            state.restoreFromSnapshot(snapshot);
            state.type = 28160 /* typeParameterStart */;
            jsxError = err;
        }
    }
    if (jsxError === null && !match(21000 /* lessThan */)) {
        return baseParseMaybeAssign(noIn, afterLeftParse);
    }
    // Either way, we're looking at a '<': tt.typeParameterStart or relational.
    let wasArrow = false;
    const snapshot = state.snapshot();
    try {
        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
        runInTypeContext(0, () => {
            tsParseTypeParameters();
        });
        wasArrow = baseParseMaybeAssign(noIn, afterLeftParse);
        if (!wasArrow) {
            unexpected(); // Go to the catch block (needs a SyntaxError).
        }
    }
    catch (err) {
        if (!(err instanceof SyntaxError)) {
            // istanbul ignore next: no such error is expected
            throw err;
        }
        if (jsxError) {
            throw jsxError;
        }
        // Try parsing a type cast instead of an arrow function.
        // This will never happen outside of JSX.
        // (Because in JSX the '<' should be a jsxTagStart and not a relational.
        assert(!hasPlugin("jsx"));
        // Parsing an arrow function failed, so try a type cast.
        state.restoreFromSnapshot(snapshot);
        // This will start with a type assertion (via parseMaybeUnary).
        // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
        return baseParseMaybeAssign(noIn, afterLeftParse);
    }
    return wasArrow;
}
export function tsParseArrow() {
    if (match(8192 /* colon */)) {
        // This is different from how the TS parser does it.
        // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
        const snapshot = state.snapshot();
        try {
            tsParseTypeOrTypePredicateAnnotation(8192 /* colon */);
            if (canInsertSemicolon())
                unexpected();
            if (!match(10752 /* arrow */))
                unexpected();
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                state.restoreFromSnapshot(snapshot);
            }
            else {
                // istanbul ignore next: no such error is expected
                throw err;
            }
        }
    }
    return eat(10752 /* arrow */);
}
// Allow type annotations inside of a parameter list.
export function tsParseAssignableListItemTypes() {
    runInTypeContext(0, () => {
        eat(9728 /* question */);
        tsTryParseTypeAnnotation();
    });
}
