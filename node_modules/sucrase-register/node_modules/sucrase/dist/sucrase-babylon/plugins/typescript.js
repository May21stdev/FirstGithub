"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../parser/base");
const expression_1 = require("../parser/expression");
const lval_1 = require("../parser/lval");
const statement_1 = require("../parser/statement");
const util_1 = require("../parser/util");
const tokenizer_1 = require("../tokenizer");
function assert(x) {
    if (!x) {
        throw new Error("Assert fail");
    }
}
function tsIsIdentifier() {
    // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
    // See https://github.com/Microsoft/TypeScript/issues/15008
    return tokenizer_1.match(2048 /* name */);
}
function tsNextTokenCanFollowModifier() {
    // Note: TypeScript's implementation is much more complicated because
    // more things are considered modifiers there.
    // This implementation only handles modifiers not handled by babylon itself. And "static".
    // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
    tokenizer_1.next();
    return (!util_1.hasPrecedingLineBreak() &&
        !tokenizer_1.match(6144 /* parenL */) &&
        !tokenizer_1.match(8192 /* colon */) &&
        !tokenizer_1.match(14368 /* eq */) &&
        !tokenizer_1.match(9728 /* question */));
}
/** Parses a modifier matching one the given modifier names. */
function tsParseModifier(allowedModifiers) {
    if (!tokenizer_1.match(2048 /* name */)) {
        return null;
    }
    const modifier = base_1.state.contextualKeyword;
    if (allowedModifiers.indexOf(modifier) !== -1 &&
        tsTryParse(() => tsNextTokenCanFollowModifier())) {
        switch (modifier) {
            case 26 /* _readonly */:
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 50192 /* _readonly */;
                break;
            case 1 /* _abstract */:
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 50704 /* _abstract */;
                break;
            case 29 /* _static */:
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 51216 /* _static */;
                break;
            case 25 /* _public */:
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 51728 /* _public */;
                break;
            case 23 /* _private */:
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 52240 /* _private */;
                break;
            case 24 /* _protected */:
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 52752 /* _protected */;
                break;
            default:
                break;
        }
        return modifier;
    }
    return null;
}
exports.tsParseModifier = tsParseModifier;
function tsIsListTerminator(kind) {
    switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
            return tokenizer_1.match(5120 /* braceR */);
        case "HeritageClauseElement":
            return tokenizer_1.match(4096 /* braceL */);
        case "TupleElementTypes":
            return tokenizer_1.match(3584 /* bracketR */);
        case "TypeParametersOrArguments":
            return tokenizer_1.match(21512 /* greaterThan */);
        default:
            break;
    }
    throw new Error("Unreachable");
}
function tsParseList(kind, parseElement) {
    while (!tsIsListTerminator(kind)) {
        // Skipping "parseListElement" from the TS source since that's just for error handling.
        parseElement();
    }
}
function tsParseDelimitedList(kind, parseElement) {
    tsParseDelimitedListWorker(kind, parseElement);
}
/**
 * If !expectSuccess, returns undefined instead of failing to parse.
 * If expectSuccess, parseElement should always return a defined value.
 */
function tsParseDelimitedListWorker(kind, parseElement) {
    while (true) {
        if (tsIsListTerminator(kind)) {
            break;
        }
        parseElement();
        if (tokenizer_1.eat(7168 /* comma */)) {
            continue;
        }
        if (tsIsListTerminator(kind)) {
            break;
        }
    }
}
function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
    if (!skipFirstToken) {
        if (bracket) {
            util_1.expect(3072 /* bracketL */);
        }
        else {
            util_1.expect(21000 /* lessThan */);
        }
    }
    tsParseDelimitedList(kind, parseElement);
    if (bracket) {
        util_1.expect(3584 /* bracketR */);
    }
    else {
        util_1.expect(21512 /* greaterThan */);
    }
}
function tsParseEntityName() {
    expression_1.parseIdentifier();
    while (tokenizer_1.eat(9216 /* dot */)) {
        expression_1.parseIdentifier();
    }
}
function tsParseTypeReference() {
    tsParseEntityName();
    if (!util_1.hasPrecedingLineBreak() && tokenizer_1.match(21000 /* lessThan */)) {
        tsParseTypeArguments();
    }
}
function tsParseThisTypePredicate() {
    tokenizer_1.next();
    tsParseTypeAnnotation();
}
function tsParseThisTypeNode() {
    tokenizer_1.next();
}
function tsParseTypeQuery() {
    util_1.expect(46736 /* _typeof */);
    tsParseEntityName();
}
function tsParseTypeParameter() {
    expression_1.parseIdentifier();
    if (tokenizer_1.eat(42000 /* _extends */)) {
        tsParseType();
    }
    if (tokenizer_1.eat(14368 /* eq */)) {
        tsParseType();
    }
}
function tsTryParseTypeParameters() {
    if (tokenizer_1.match(21000 /* lessThan */)) {
        tsParseTypeParameters();
    }
}
exports.tsTryParseTypeParameters = tsTryParseTypeParameters;
function tsParseTypeParameters() {
    tokenizer_1.runInTypeContext(0, () => {
        if (tokenizer_1.match(21000 /* lessThan */) || tokenizer_1.match(28160 /* typeParameterStart */)) {
            tokenizer_1.next();
        }
        else {
            util_1.unexpected();
        }
        tsParseBracketedList("TypeParametersOrArguments", tsParseTypeParameter, 
        /* bracket */ false, 
        /* skipFirstToken */ true);
    });
}
// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
// but here it's always false, because this is only used for types.
function tsFillSignature(returnToken) {
    // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
    const returnTokenRequired = returnToken === 10752 /* arrow */;
    tsTryParseTypeParameters();
    util_1.expect(6144 /* parenL */);
    tsParseBindingListForSignature(false /* isBlockScope */);
    if (returnTokenRequired) {
        tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
    else if (tokenizer_1.match(returnToken)) {
        tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
}
function tsParseBindingListForSignature(isBlockScope) {
    lval_1.parseBindingList(6656 /* parenR */, isBlockScope);
}
function tsParseTypeMemberSemicolon() {
    if (!tokenizer_1.eat(7168 /* comma */)) {
        util_1.semicolon();
    }
}
function tsParseSignatureMember(kind) {
    if (kind === "TSConstructSignatureDeclaration") {
        util_1.expect(39952 /* _new */);
    }
    tsFillSignature(8192 /* colon */);
    tsParseTypeMemberSemicolon();
}
function tsIsUnambiguouslyIndexSignature() {
    tokenizer_1.next(); // Skip '{'
    return tokenizer_1.eat(2048 /* name */) && tokenizer_1.match(8192 /* colon */);
}
function tsTryParseIndexSignature() {
    if (!(tokenizer_1.match(3072 /* bracketL */) && tsLookAhead(tsIsUnambiguouslyIndexSignature))) {
        return false;
    }
    util_1.expect(3072 /* bracketL */);
    expression_1.parseIdentifier();
    tsParseTypeAnnotation();
    util_1.expect(3584 /* bracketR */);
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
    return true;
}
function tsParsePropertyOrMethodSignature(readonly) {
    expression_1.parsePropertyName(-1 /* Types don't need context IDs. */);
    tokenizer_1.eat(9728 /* question */);
    if (!readonly && (tokenizer_1.match(6144 /* parenL */) || tokenizer_1.match(21000 /* lessThan */))) {
        tsFillSignature(8192 /* colon */);
        tsParseTypeMemberSemicolon();
    }
    else {
        tsTryParseTypeAnnotation();
        tsParseTypeMemberSemicolon();
    }
}
function tsParseTypeMember() {
    if (tokenizer_1.match(6144 /* parenL */) || tokenizer_1.match(21000 /* lessThan */)) {
        tsParseSignatureMember("TSCallSignatureDeclaration");
        return;
    }
    if (tokenizer_1.match(39952 /* _new */) && tsLookAhead(tsIsStartOfConstructSignature)) {
        tsParseSignatureMember("TSConstructSignatureDeclaration");
        return;
    }
    const readonly = !!tsParseModifier([26 /* _readonly */]);
    const found = tsTryParseIndexSignature();
    if (found) {
        return;
    }
    tsParsePropertyOrMethodSignature(readonly);
}
function tsIsStartOfConstructSignature() {
    tokenizer_1.next();
    return tokenizer_1.match(6144 /* parenL */) || tokenizer_1.match(21000 /* lessThan */);
}
function tsParseTypeLiteral() {
    tsParseObjectTypeMembers();
}
function tsParseObjectTypeMembers() {
    util_1.expect(4096 /* braceL */);
    tsParseList("TypeMembers", tsParseTypeMember);
    util_1.expect(5120 /* braceR */);
}
function tsIsStartOfMappedType() {
    tokenizer_1.next();
    if (tokenizer_1.eat(23178 /* plus */) || tokenizer_1.eat(23690 /* minus */)) {
        return util_1.isContextual(26 /* _readonly */);
    }
    if (util_1.isContextual(26 /* _readonly */)) {
        tokenizer_1.next();
    }
    if (!tokenizer_1.match(3072 /* bracketL */)) {
        return false;
    }
    tokenizer_1.next();
    if (!tsIsIdentifier()) {
        return false;
    }
    tokenizer_1.next();
    return tokenizer_1.match(45592 /* _in */);
}
function tsParseMappedTypeParameter() {
    expression_1.parseIdentifier();
    util_1.expect(45592 /* _in */);
    tsParseType();
}
function tsParseMappedType() {
    util_1.expect(4096 /* braceL */);
    if (tokenizer_1.match(23178 /* plus */) || tokenizer_1.match(23690 /* minus */)) {
        tokenizer_1.next();
        util_1.expectContextual(26 /* _readonly */);
    }
    else {
        util_1.eatContextual(26 /* _readonly */);
    }
    util_1.expect(3072 /* bracketL */);
    tsParseMappedTypeParameter();
    util_1.expect(3584 /* bracketR */);
    if (tokenizer_1.match(23178 /* plus */) || tokenizer_1.match(23690 /* minus */)) {
        tokenizer_1.next();
        util_1.expect(9728 /* question */);
    }
    else {
        tokenizer_1.eat(9728 /* question */);
    }
    tsTryParseType();
    util_1.semicolon();
    util_1.expect(5120 /* braceR */);
}
function tsParseTupleType() {
    tsParseBracketedList("TupleElementTypes", tsParseType, 
    /* bracket */ true, 
    /* skipFirstToken */ false);
}
function tsParseParenthesizedType() {
    util_1.expect(6144 /* parenL */);
    tsParseType();
    util_1.expect(6656 /* parenR */);
}
function tsParseFunctionOrConstructorType(type) {
    if (type === "TSConstructorType") {
        util_1.expect(39952 /* _new */);
    }
    tsFillSignature(10752 /* arrow */);
}
function tsParseNonArrayType() {
    switch (base_1.state.type) {
        case 2048 /* name */:
            tsParseTypeReference();
            return;
        case 47248 /* _void */:
        case 44048 /* _null */:
            tokenizer_1.next();
            return;
        case 1536 /* string */:
        case 0 /* num */:
        case 44560 /* _true */:
        case 45072 /* _false */:
            expression_1.parseLiteral();
            return;
        case 23690 /* minus */:
            tokenizer_1.next();
            expression_1.parseLiteral();
            return;
        case 40464 /* _this */: {
            tsParseThisTypeNode();
            if (util_1.isContextual(16 /* _is */) && !util_1.hasPrecedingLineBreak()) {
                tsParseThisTypePredicate();
            }
            return;
        }
        case 46736 /* _typeof */:
            tsParseTypeQuery();
            return;
        case 4096 /* braceL */:
            if (tsLookAhead(tsIsStartOfMappedType)) {
                tsParseMappedType();
            }
            else {
                tsParseTypeLiteral();
            }
            return;
        case 3072 /* bracketL */:
            tsParseTupleType();
            return;
        case 6144 /* parenL */:
            tsParseParenthesizedType();
            return;
        default:
            break;
    }
    throw util_1.unexpected();
}
function tsParseArrayTypeOrHigher() {
    tsParseNonArrayType();
    while (!util_1.hasPrecedingLineBreak() && tokenizer_1.eat(3072 /* bracketL */)) {
        if (!tokenizer_1.eat(3584 /* bracketR */)) {
            // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
            tsParseType();
            util_1.expect(3584 /* bracketR */);
        }
    }
}
function tsParseInferType() {
    util_1.expectContextual(14 /* _infer */);
    expression_1.parseIdentifier();
}
function tsParseTypeOperatorOrHigher() {
    if (util_1.isContextual(17 /* _keyof */) || util_1.isContextual(31 /* _unique */)) {
        tokenizer_1.next();
        tsParseTypeOperatorOrHigher();
    }
    else if (util_1.isContextual(14 /* _infer */)) {
        tsParseInferType();
    }
    else {
        tsParseArrayTypeOrHigher();
    }
}
function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
    tokenizer_1.eat(operator);
    parseConstituentType();
    if (tokenizer_1.match(operator)) {
        while (tokenizer_1.eat(operator)) {
            parseConstituentType();
        }
    }
}
function tsParseIntersectionTypeOrHigher() {
    tsParseUnionOrIntersectionType("TSIntersectionType", tsParseTypeOperatorOrHigher, 19974 /* bitwiseAND */);
}
function tsParseUnionTypeOrHigher() {
    tsParseUnionOrIntersectionType("TSUnionType", tsParseIntersectionTypeOrHigher, 18948 /* bitwiseOR */);
}
function tsIsStartOfFunctionType() {
    if (tokenizer_1.match(21000 /* lessThan */)) {
        return true;
    }
    return tokenizer_1.match(6144 /* parenL */) && tsLookAhead(tsIsUnambiguouslyStartOfFunctionType);
}
function tsSkipParameterStart() {
    if (tokenizer_1.match(2048 /* name */) || tokenizer_1.match(40464 /* _this */)) {
        tokenizer_1.next();
        return true;
    }
    return false;
}
function tsIsUnambiguouslyStartOfFunctionType() {
    tokenizer_1.next();
    if (tokenizer_1.match(6656 /* parenR */) || tokenizer_1.match(11776 /* ellipsis */)) {
        // ( )
        // ( ...
        return true;
    }
    if (tsSkipParameterStart()) {
        if (tokenizer_1.match(8192 /* colon */) || tokenizer_1.match(7168 /* comma */) || tokenizer_1.match(9728 /* question */) || tokenizer_1.match(14368 /* eq */)) {
            // ( xxx :
            // ( xxx ,
            // ( xxx ?
            // ( xxx =
            return true;
        }
        if (tokenizer_1.match(6656 /* parenR */)) {
            tokenizer_1.next();
            if (tokenizer_1.match(10752 /* arrow */)) {
                // ( xxx ) =>
                return true;
            }
        }
    }
    return false;
}
function tsParseTypeOrTypePredicateAnnotation(returnToken) {
    tokenizer_1.runInTypeContext(0, () => {
        util_1.expect(returnToken);
        tsTryParse(() => tsParseTypePredicatePrefix());
        // Regardless of whether we found an "is" token, there's now just a regular type in front of
        // us.
        tsParseType();
    });
}
function tsTryParseTypeOrTypePredicateAnnotation() {
    if (tokenizer_1.match(8192 /* colon */)) {
        tsParseTypeOrTypePredicateAnnotation(8192 /* colon */);
    }
}
function tsTryParseTypeAnnotation() {
    if (tokenizer_1.match(8192 /* colon */)) {
        tsParseTypeAnnotation();
    }
}
exports.tsTryParseTypeAnnotation = tsTryParseTypeAnnotation;
function tsTryParseType() {
    if (tokenizer_1.eat(8192 /* colon */)) {
        tsParseType();
    }
}
function tsParseTypePredicatePrefix() {
    expression_1.parseIdentifier();
    if (util_1.isContextual(16 /* _is */) && !util_1.hasPrecedingLineBreak()) {
        tokenizer_1.next();
        return true;
    }
    return false;
}
function tsParseTypeAnnotation() {
    tokenizer_1.runInTypeContext(0, () => {
        util_1.expect(8192 /* colon */);
        tsParseType();
    });
}
exports.tsParseTypeAnnotation = tsParseTypeAnnotation;
function tsParseType() {
    tsParseNonConditionalType();
    if (util_1.hasPrecedingLineBreak() || !tokenizer_1.eat(42000 /* _extends */)) {
        return;
    }
    // extends type
    tsParseNonConditionalType();
    util_1.expect(9728 /* question */);
    // true type
    tsParseType();
    util_1.expect(8192 /* colon */);
    // false type
    tsParseType();
}
exports.tsParseType = tsParseType;
function tsParseNonConditionalType() {
    if (tsIsStartOfFunctionType()) {
        tsParseFunctionOrConstructorType("TSFunctionType");
        return;
    }
    if (tokenizer_1.match(39952 /* _new */)) {
        // As in `new () => Date`
        tsParseFunctionOrConstructorType("TSConstructorType");
        return;
    }
    tsParseUnionTypeOrHigher();
}
exports.tsParseNonConditionalType = tsParseNonConditionalType;
function tsParseTypeAssertion() {
    tokenizer_1.runInTypeContext(1, () => {
        tsParseType();
        util_1.expect(21512 /* greaterThan */);
    });
    expression_1.parseMaybeUnary();
}
exports.tsParseTypeAssertion = tsParseTypeAssertion;
// Returns true if parsing was successful.
function tsTryParseTypeArgumentsInExpression() {
    return tsTryParseAndCatch(() => {
        tokenizer_1.runInTypeContext(0, () => {
            util_1.expect(21000 /* lessThan */);
            base_1.state.tokens[base_1.state.tokens.length - 1].type = 28160 /* typeParameterStart */;
            tsParseDelimitedList("TypeParametersOrArguments", tsParseType);
            util_1.expect(21512 /* greaterThan */);
        });
        util_1.expect(6144 /* parenL */);
    });
}
function tsParseHeritageClause() {
    tsParseDelimitedList("HeritageClauseElement", tsParseExpressionWithTypeArguments);
}
function tsParseExpressionWithTypeArguments() {
    // Note: TS uses parseLeftHandSideExpressionOrHigher,
    // then has grammar errors later if it's not an EntityName.
    tsParseEntityName();
    if (tokenizer_1.match(21000 /* lessThan */)) {
        tsParseTypeArguments();
    }
}
function tsParseInterfaceDeclaration() {
    expression_1.parseIdentifier();
    tsTryParseTypeParameters();
    if (tokenizer_1.eat(42000 /* _extends */)) {
        tsParseHeritageClause();
    }
    tsParseObjectTypeMembers();
}
function tsParseTypeAliasDeclaration() {
    expression_1.parseIdentifier();
    tsTryParseTypeParameters();
    util_1.expect(14368 /* eq */);
    tsParseType();
    util_1.semicolon();
}
function tsParseEnumMember() {
    // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
    if (tokenizer_1.match(1536 /* string */)) {
        expression_1.parseLiteral();
    }
    else {
        expression_1.parseIdentifier();
    }
    if (tokenizer_1.eat(14368 /* eq */)) {
        const eqIndex = base_1.state.tokens.length - 1;
        expression_1.parseMaybeAssign();
        base_1.state.tokens[eqIndex].rhsEndIndex = base_1.state.tokens.length;
    }
}
function tsParseEnumDeclaration() {
    expression_1.parseIdentifier();
    util_1.expect(4096 /* braceL */);
    tsParseDelimitedList("EnumMembers", tsParseEnumMember);
    util_1.expect(5120 /* braceR */);
}
function tsParseModuleBlock() {
    util_1.expect(4096 /* braceL */);
    // Inside of a module block is considered "top-level", meaning it can have imports and exports.
    statement_1.parseBlockBody(/* topLevel */ true, /* end */ 5120 /* braceR */);
}
function tsParseModuleOrNamespaceDeclaration() {
    expression_1.parseIdentifier();
    if (tokenizer_1.eat(9216 /* dot */)) {
        tsParseModuleOrNamespaceDeclaration();
    }
    else {
        tsParseModuleBlock();
    }
}
function tsParseAmbientExternalModuleDeclaration() {
    if (util_1.isContextual(12 /* _global */)) {
        expression_1.parseIdentifier();
    }
    else if (tokenizer_1.match(1536 /* string */)) {
        expression_1.parseExprAtom();
    }
    else {
        util_1.unexpected();
    }
    if (tokenizer_1.match(4096 /* braceL */)) {
        tsParseModuleBlock();
    }
    else {
        util_1.semicolon();
    }
}
function tsParseImportEqualsDeclaration() {
    expression_1.parseIdentifier();
    util_1.expect(14368 /* eq */);
    tsParseModuleReference();
    util_1.semicolon();
}
exports.tsParseImportEqualsDeclaration = tsParseImportEqualsDeclaration;
function tsIsExternalModuleReference() {
    return util_1.isContextual(27 /* _require */) && tokenizer_1.lookaheadType() === 6144 /* parenL */;
}
function tsParseModuleReference() {
    if (tsIsExternalModuleReference()) {
        tsParseExternalModuleReference();
    }
    else {
        tsParseEntityName();
    }
}
function tsParseExternalModuleReference() {
    util_1.expectContextual(27 /* _require */);
    util_1.expect(6144 /* parenL */);
    if (!tokenizer_1.match(1536 /* string */)) {
        throw util_1.unexpected();
    }
    expression_1.parseLiteral();
    util_1.expect(6656 /* parenR */);
}
// Utilities
function tsLookAhead(f) {
    const snapshot = base_1.state.snapshot();
    const res = f();
    base_1.state.restoreFromSnapshot(snapshot);
    return res;
}
// Returns true if parsing was successful.
function tsTryParseAndCatch(f) {
    const snapshot = base_1.state.snapshot();
    try {
        f();
        return true;
    }
    catch (e) {
        if (e instanceof SyntaxError) {
            base_1.state.restoreFromSnapshot(snapshot);
            return false;
        }
        throw e;
    }
}
// The function should return true if the parse was successful. If not, we revert the state to
// before we started parsing.
function tsTryParse(f) {
    const snapshot = base_1.state.snapshot();
    const wasSuccessful = f();
    if (wasSuccessful) {
        return true;
    }
    else {
        base_1.state.restoreFromSnapshot(snapshot);
        return false;
    }
}
// Returns true if a statement matched.
function tsTryParseDeclare() {
    switch (base_1.state.type) {
        case 34320 /* _function */:
            tokenizer_1.runInTypeContext(1, () => {
                tokenizer_1.next();
                // We don't need to precisely get the function start here, since it's only used to mark
                // the function as a type if it's bodiless, and it's already a type here.
                const functionStart = base_1.state.start;
                statement_1.parseFunction(functionStart, /* isStatement */ true);
            });
            return true;
        case 41488 /* _class */:
            tokenizer_1.runInTypeContext(1, () => {
                statement_1.parseClass(/* isStatement */ true, /* optionalId */ false);
            });
            return true;
        case 38416 /* _const */:
            if (tokenizer_1.match(38416 /* _const */) && util_1.isLookaheadContextual(8 /* _enum */)) {
                tokenizer_1.runInTypeContext(1, () => {
                    // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
                    util_1.expect(38416 /* _const */);
                    util_1.expectContextual(8 /* _enum */);
                    base_1.state.tokens[base_1.state.tokens.length - 1].type = 53776 /* _enum */;
                    tsParseEnumDeclaration();
                });
                return true;
            }
        // falls through
        case 37392 /* _var */:
        case 37904 /* _let */:
            tokenizer_1.runInTypeContext(1, () => {
                statement_1.parseVarStatement(base_1.state.type);
            });
            return true;
        case 2048 /* name */: {
            return tokenizer_1.runInTypeContext(1, () => {
                const contextualKeyword = base_1.state.contextualKeyword;
                if (contextualKeyword === 12 /* _global */) {
                    tsParseAmbientExternalModuleDeclaration();
                    return true;
                }
                else {
                    return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);
                }
            });
        }
        default:
            return false;
    }
}
// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.
function tsTryParseExportDeclaration() {
    return tsParseDeclaration(base_1.state.contextualKeyword, /* isBeforeToken */ true);
}
// Returns true if it matched a statement.
function tsParseExpressionStatement(contextualKeyword) {
    switch (contextualKeyword) {
        case 7 /* _declare */: {
            const declareTokenIndex = base_1.state.tokens.length - 1;
            const matched = tsTryParseDeclare();
            if (matched) {
                base_1.state.tokens[declareTokenIndex].type = 49680 /* _declare */;
                return true;
            }
            break;
        }
        case 12 /* _global */:
            // `global { }` (with no `declare`) may appear inside an ambient module declaration.
            // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
            if (tokenizer_1.match(4096 /* braceL */)) {
                tsParseModuleBlock();
                return true;
            }
            break;
        default:
            return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);
    }
    return false;
}
// Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
// Returns true if it matched a declaration.
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
    switch (contextualKeyword) {
        case 1 /* _abstract */:
            if (isBeforeToken || tokenizer_1.match(41488 /* _class */)) {
                if (isBeforeToken)
                    tokenizer_1.next();
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 50704 /* _abstract */;
                statement_1.parseClass(/* isStatement */ true, /* optionalId */ false);
                return true;
            }
            break;
        case 8 /* _enum */:
            if (isBeforeToken || tokenizer_1.match(2048 /* name */)) {
                if (isBeforeToken)
                    tokenizer_1.next();
                base_1.state.tokens[base_1.state.tokens.length - 1].type = 53776 /* _enum */;
                tsParseEnumDeclaration();
                return true;
            }
            break;
        case 15 /* _interface */:
            if (isBeforeToken || tokenizer_1.match(2048 /* name */)) {
                // `next` is true in "export" and "declare" contexts, so we want to remove that token
                // as well.
                tokenizer_1.runInTypeContext(1, () => {
                    if (isBeforeToken)
                        tokenizer_1.next();
                    tsParseInterfaceDeclaration();
                });
                return true;
            }
            break;
        case 19 /* _module */:
            if (isBeforeToken)
                tokenizer_1.next();
            if (tokenizer_1.match(1536 /* string */)) {
                tokenizer_1.runInTypeContext(isBeforeToken ? 2 : 1, () => {
                    tsParseAmbientExternalModuleDeclaration();
                });
                return true;
            }
            else if (tokenizer_1.next || tokenizer_1.match(2048 /* name */)) {
                tokenizer_1.runInTypeContext(isBeforeToken ? 2 : 1, () => {
                    tsParseModuleOrNamespaceDeclaration();
                });
                return true;
            }
            break;
        case 20 /* _namespace */:
            if (isBeforeToken || tokenizer_1.match(2048 /* name */)) {
                tokenizer_1.runInTypeContext(1, () => {
                    if (isBeforeToken)
                        tokenizer_1.next();
                    tsParseModuleOrNamespaceDeclaration();
                });
                return true;
            }
            break;
        case 30 /* _type */:
            if (isBeforeToken || tokenizer_1.match(2048 /* name */)) {
                tokenizer_1.runInTypeContext(1, () => {
                    if (isBeforeToken)
                        tokenizer_1.next();
                    tsParseTypeAliasDeclaration();
                });
                return true;
            }
            break;
        default:
            break;
    }
    return false;
}
// Returns true if there was a generic async arrow function.
function tsTryParseGenericAsyncArrowFunction() {
    const matched = tsTryParseAndCatch(() => {
        tsParseTypeParameters();
        statement_1.parseFunctionParams();
        tsTryParseTypeOrTypePredicateAnnotation();
        util_1.expect(10752 /* arrow */);
    });
    if (!matched) {
        return false;
    }
    // We don't need to be precise about the function start since it's only used if this is a
    // bodiless function, which isn't valid here.
    const functionStart = base_1.state.start;
    expression_1.parseFunctionBody(functionStart, false /* isGenerator */, true);
    return true;
}
function tsParseTypeArguments() {
    tokenizer_1.runInTypeContext(0, () => {
        util_1.expect(21000 /* lessThan */);
        tsParseDelimitedList("TypeParametersOrArguments", tsParseType);
        util_1.expect(21512 /* greaterThan */);
    });
}
function tsIsDeclarationStart() {
    if (tokenizer_1.match(2048 /* name */)) {
        switch (base_1.state.contextualKeyword) {
            case 1 /* _abstract */:
            case 7 /* _declare */:
            case 8 /* _enum */:
            case 15 /* _interface */:
            case 19 /* _module */:
            case 20 /* _namespace */:
            case 30 /* _type */:
                return true;
            default:
                break;
        }
    }
    return false;
}
exports.tsIsDeclarationStart = tsIsDeclarationStart;
// ======================================================
// OVERRIDES
// ======================================================
function tsParseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody = null, funcContextId) {
    // For arrow functions, `parseArrow` handles the return type itself.
    if (!allowExpressionBody && tokenizer_1.match(8192 /* colon */)) {
        tsParseTypeOrTypePredicateAnnotation(8192 /* colon */);
    }
    // The original code checked the node type to make sure this function type allows a missing
    // body, but we skip that to avoid sending around the node type. We instead just use the
    // allowExpressionBody boolean to make sure it's not an arrow function.
    if (!allowExpressionBody && !tokenizer_1.match(4096 /* braceL */) && util_1.isLineTerminator()) {
        // Retroactively mark the function declaration as a type.
        let i = base_1.state.tokens.length - 1;
        while (i >= 0 &&
            (base_1.state.tokens[i].start >= functionStart ||
                base_1.state.tokens[i].type === 31760 /* _default */ ||
                base_1.state.tokens[i].type === 42512 /* _export */)) {
            base_1.state.tokens[i].isType = true;
            i--;
        }
        return;
    }
    expression_1.parseFunctionBody(functionStart, isGenerator, allowExpressionBody, funcContextId);
}
exports.tsParseFunctionBodyAndFinish = tsParseFunctionBodyAndFinish;
function tsParseSubscript(startPos, noCalls, stopState) {
    if (!util_1.hasPrecedingLineBreak() && tokenizer_1.eat(16000 /* bang */)) {
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 28672 /* nonNullAssertion */;
        return;
    }
    if (!noCalls && tokenizer_1.match(21000 /* lessThan */)) {
        if (expression_1.atPossibleAsync()) {
            // Almost certainly this is a generic async function `async <T>() => ...
            // But it might be a call with a type argument `async<T>();`
            const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
            if (asyncArrowFn) {
                return;
            }
        }
        // May be passing type arguments. But may just be the `<` operator.
        const typeArguments = tsTryParseTypeArgumentsInExpression(); // Also eats the "("
        if (typeArguments) {
            // possibleAsync always false here, because we would have handled it above.
            expression_1.parseCallExpressionArguments(6656 /* parenR */);
        }
    }
    expression_1.baseParseSubscript(startPos, noCalls, stopState);
}
exports.tsParseSubscript = tsParseSubscript;
function tsStartParseNewArguments() {
    if (tokenizer_1.match(21000 /* lessThan */)) {
        // tsTryParseAndCatch is expensive, so avoid if not necessary.
        // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.
        tsTryParseAndCatch(() => {
            base_1.state.type = 28160 /* typeParameterStart */;
            tsParseTypeArguments();
            if (!tokenizer_1.match(6144 /* parenL */)) {
                util_1.unexpected();
            }
        });
    }
}
exports.tsStartParseNewArguments = tsStartParseNewArguments;
function tsTryParseExport() {
    if (tokenizer_1.match(43024 /* _import */)) {
        // `export import A = B;`
        util_1.expect(43024 /* _import */);
        tsParseImportEqualsDeclaration();
        return true;
    }
    else if (tokenizer_1.eat(14368 /* eq */)) {
        // `export = x;`
        expression_1.parseExpression();
        util_1.semicolon();
        return true;
    }
    else if (util_1.eatContextual(2 /* _as */)) {
        // `export as namespace A;`
        // See `parseNamespaceExportDeclaration` in TypeScript's own parser
        util_1.expectContextual(20 /* _namespace */);
        expression_1.parseIdentifier();
        util_1.semicolon();
        return true;
    }
    else {
        return false;
    }
}
exports.tsTryParseExport = tsTryParseExport;
function tsTryParseExportDefaultExpression() {
    if (util_1.isContextual(1 /* _abstract */) && tokenizer_1.lookaheadType() === 41488 /* _class */) {
        base_1.state.type = 50704 /* _abstract */;
        tokenizer_1.next(); // Skip "abstract"
        statement_1.parseClass(true, true);
        return true;
    }
    return false;
}
exports.tsTryParseExportDefaultExpression = tsTryParseExportDefaultExpression;
function tsTryParseStatementContent() {
    if (base_1.state.type === 38416 /* _const */) {
        const ahead = tokenizer_1.lookaheadTypeAndKeyword();
        if (ahead.type === 2048 /* name */ && ahead.contextualKeyword === 8 /* _enum */) {
            util_1.expect(38416 /* _const */);
            util_1.expectContextual(8 /* _enum */);
            base_1.state.tokens[base_1.state.tokens.length - 1].type = 53776 /* _enum */;
            tsParseEnumDeclaration();
            return true;
        }
    }
    return false;
}
exports.tsTryParseStatementContent = tsTryParseStatementContent;
function tsParseAccessModifier() {
    tsParseModifier([
        25 /* _public */,
        24 /* _protected */,
        23 /* _private */,
    ]);
}
exports.tsParseAccessModifier = tsParseAccessModifier;
function tsTryParseClassMemberWithIsStatic(isStatic, classContextId) {
    let isAbstract = false;
    let isReadonly = false;
    const mod = tsParseModifier([1 /* _abstract */, 26 /* _readonly */]);
    switch (mod) {
        case 26 /* _readonly */:
            isReadonly = true;
            isAbstract = !!tsParseModifier([1 /* _abstract */]);
            break;
        case 1 /* _abstract */:
            isAbstract = true;
            isReadonly = !!tsParseModifier([26 /* _readonly */]);
            break;
        default:
            break;
    }
    // We no longer check for public/private/etc, but tsTryParseIndexSignature should just return
    // false in that case for valid code.
    if (!isAbstract && !isStatic) {
        const found = tsTryParseIndexSignature();
        if (found) {
            return true;
        }
    }
    if (isReadonly) {
        // Must be a property (if not an index signature).
        statement_1.parseClassPropertyName(classContextId);
        statement_1.parsePostMemberNameModifiers();
        statement_1.parseClassProperty();
        return true;
    }
    return false;
}
exports.tsTryParseClassMemberWithIsStatic = tsTryParseClassMemberWithIsStatic;
// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
// is that e.g. `type()` is valid JS, so we must try parsing that first.
// If it's really a type, we will parse `type` as the statement, and can correct it here
// by parsing the rest.
function tsParseIdentifierStatement(contextualKeyword) {
    const matched = tsParseExpressionStatement(contextualKeyword);
    if (!matched) {
        util_1.semicolon();
    }
}
exports.tsParseIdentifierStatement = tsParseIdentifierStatement;
function tsParseExportDeclaration() {
    // "export declare" is equivalent to just "export".
    const isDeclare = util_1.eatContextual(7 /* _declare */);
    if (isDeclare) {
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 49680 /* _declare */;
    }
    let matchedDeclaration = false;
    if (tokenizer_1.match(2048 /* name */)) {
        if (isDeclare) {
            matchedDeclaration = tokenizer_1.runInTypeContext(2, () => tsTryParseExportDeclaration());
        }
        else {
            matchedDeclaration = tsTryParseExportDeclaration();
        }
    }
    if (!matchedDeclaration) {
        if (isDeclare) {
            tokenizer_1.runInTypeContext(2, () => {
                statement_1.parseStatement(true);
            });
        }
        else {
            statement_1.parseStatement(true);
        }
    }
}
exports.tsParseExportDeclaration = tsParseExportDeclaration;
function tsAfterParseClassSuper(hasSuper) {
    if (hasSuper && tokenizer_1.match(21000 /* lessThan */)) {
        tsParseTypeArguments();
    }
    if (util_1.eatContextual(13 /* _implements */)) {
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 54800 /* _implements */;
        tokenizer_1.runInTypeContext(1, () => {
            tsParseHeritageClause();
        });
    }
}
exports.tsAfterParseClassSuper = tsAfterParseClassSuper;
function tsStartParseObjPropValue() {
    if (tokenizer_1.match(21000 /* lessThan */)) {
        throw new Error("TODO");
    }
}
exports.tsStartParseObjPropValue = tsStartParseObjPropValue;
function tsStartParseFunctionParams() {
    tsTryParseTypeParameters();
}
exports.tsStartParseFunctionParams = tsStartParseFunctionParams;
// `let x: number;`
function tsAfterParseVarHead() {
    tokenizer_1.eat(16000 /* bang */);
    tsTryParseTypeAnnotation();
}
exports.tsAfterParseVarHead = tsAfterParseVarHead;
// parse the return type of an async arrow function - let foo = (async (): number => {});
function tsStartParseAsyncArrowFromCallExpression() {
    if (tokenizer_1.match(8192 /* colon */)) {
        tsParseTypeAnnotation();
    }
}
exports.tsStartParseAsyncArrowFromCallExpression = tsStartParseAsyncArrowFromCallExpression;
// Returns true if the expression was an arrow function.
function tsParseMaybeAssign(noIn = null, afterLeftParse) {
    // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
    let jsxError = null;
    if (tokenizer_1.match(21000 /* lessThan */) && base_1.hasPlugin("jsx")) {
        // Prefer to parse JSX if possible. But may be an arrow fn.
        const snapshot = base_1.state.snapshot();
        try {
            return expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
        }
        catch (err) {
            if (!(err instanceof SyntaxError)) {
                // istanbul ignore next: no such error is expected
                throw err;
            }
            base_1.state.restoreFromSnapshot(snapshot);
            base_1.state.type = 28160 /* typeParameterStart */;
            jsxError = err;
        }
    }
    if (jsxError === null && !tokenizer_1.match(21000 /* lessThan */)) {
        return expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
    }
    // Either way, we're looking at a '<': tt.typeParameterStart or relational.
    let wasArrow = false;
    const snapshot = base_1.state.snapshot();
    try {
        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
        tokenizer_1.runInTypeContext(0, () => {
            tsParseTypeParameters();
        });
        wasArrow = expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
        if (!wasArrow) {
            util_1.unexpected(); // Go to the catch block (needs a SyntaxError).
        }
    }
    catch (err) {
        if (!(err instanceof SyntaxError)) {
            // istanbul ignore next: no such error is expected
            throw err;
        }
        if (jsxError) {
            throw jsxError;
        }
        // Try parsing a type cast instead of an arrow function.
        // This will never happen outside of JSX.
        // (Because in JSX the '<' should be a jsxTagStart and not a relational.
        assert(!base_1.hasPlugin("jsx"));
        // Parsing an arrow function failed, so try a type cast.
        base_1.state.restoreFromSnapshot(snapshot);
        // This will start with a type assertion (via parseMaybeUnary).
        // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
        return expression_1.baseParseMaybeAssign(noIn, afterLeftParse);
    }
    return wasArrow;
}
exports.tsParseMaybeAssign = tsParseMaybeAssign;
function tsParseArrow() {
    if (tokenizer_1.match(8192 /* colon */)) {
        // This is different from how the TS parser does it.
        // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
        const snapshot = base_1.state.snapshot();
        try {
            tsParseTypeOrTypePredicateAnnotation(8192 /* colon */);
            if (util_1.canInsertSemicolon())
                util_1.unexpected();
            if (!tokenizer_1.match(10752 /* arrow */))
                util_1.unexpected();
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                base_1.state.restoreFromSnapshot(snapshot);
            }
            else {
                // istanbul ignore next: no such error is expected
                throw err;
            }
        }
    }
    return tokenizer_1.eat(10752 /* arrow */);
}
exports.tsParseArrow = tsParseArrow;
// Allow type annotations inside of a parameter list.
function tsParseAssignableListItemTypes() {
    tokenizer_1.runInTypeContext(0, () => {
        tokenizer_1.eat(9728 /* question */);
        tsTryParseTypeAnnotation();
    });
}
exports.tsParseAssignableListItemTypes = tsParseAssignableListItemTypes;
