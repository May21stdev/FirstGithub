/* eslint max-len: 0 */
import { input, state } from "../parser/base";
import { baseParseMaybeAssign, baseParseSubscripts, parseArrow, parseArrowExpression, parseExprAtom, parseExpression, parseFunctionBody, parseIdentifier, parseLiteral, } from "../parser/expression";
import { baseParseExportStar, parseExport, parseExportFrom, parseExportSpecifiers, parseFunctionParams, parseImport, parseStatement, } from "../parser/statement";
import { canInsertSemicolon, eatContextual, expect, expectContextual, isContextual, isLookaheadContextual, semicolon, unexpected, } from "../parser/util";
import { eat, lookaheadType, lookaheadTypeAndKeyword, match, next, runInTypeContext, } from "../tokenizer";
function isMaybeDefaultImport(lookahead) {
    return ((lookahead.type === 2048 /* name */ || !!(lookahead.type & 16 /* IS_KEYWORD */)) &&
        lookahead.contextualKeyword !== 10 /* _from */);
}
function flowParseTypeInitialiser(tok) {
    runInTypeContext(0, () => {
        expect(tok || 8192 /* colon */);
        flowParseType();
    });
}
function flowParsePredicate() {
    expect(24075 /* modulo */);
    expectContextual(5 /* _checks */);
    if (eat(6144 /* parenL */)) {
        parseExpression();
        expect(6656 /* parenR */);
    }
}
function flowParseTypeAndPredicateInitialiser() {
    runInTypeContext(0, () => {
        expect(8192 /* colon */);
        if (match(24075 /* modulo */)) {
            flowParsePredicate();
        }
        else {
            flowParseType();
            if (match(24075 /* modulo */)) {
                flowParsePredicate();
            }
        }
    });
}
function flowParseDeclareClass() {
    next();
    flowParseInterfaceish(/* isClass */ true);
}
function flowParseDeclareFunction() {
    next();
    parseIdentifier();
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    expect(6144 /* parenL */);
    flowParseFunctionTypeParams();
    expect(6656 /* parenR */);
    flowParseTypeAndPredicateInitialiser();
    semicolon();
}
function flowParseDeclare() {
    if (match(41488 /* _class */)) {
        flowParseDeclareClass();
    }
    else if (match(34320 /* _function */)) {
        flowParseDeclareFunction();
    }
    else if (match(37392 /* _var */)) {
        flowParseDeclareVariable();
    }
    else if (isContextual(19 /* _module */)) {
        if (lookaheadType() === 9216 /* dot */) {
            flowParseDeclareModuleExports();
        }
        else {
            flowParseDeclareModule();
        }
    }
    else if (isContextual(30 /* _type */)) {
        flowParseDeclareTypeAlias();
    }
    else if (isContextual(22 /* _opaque */)) {
        flowParseDeclareOpaqueType();
    }
    else if (isContextual(15 /* _interface */)) {
        flowParseDeclareInterface();
    }
    else if (match(42512 /* _export */)) {
        flowParseDeclareExportDeclaration();
    }
    else {
        throw unexpected();
    }
}
function flowParseDeclareVariable() {
    next();
    flowParseTypeAnnotatableIdentifier();
    semicolon();
}
function flowParseDeclareModule() {
    next();
    if (match(1536 /* string */)) {
        parseExprAtom();
    }
    else {
        parseIdentifier();
    }
    expect(4096 /* braceL */);
    while (!match(5120 /* braceR */)) {
        if (match(43024 /* _import */)) {
            next();
            parseImport();
        }
    }
    expect(5120 /* braceR */);
}
function flowParseDeclareExportDeclaration() {
    expect(42512 /* _export */);
    if (eat(31760 /* _default */)) {
        if (match(34320 /* _function */) || match(41488 /* _class */)) {
            // declare export default class ...
            // declare export default function ...
            flowParseDeclare();
        }
        else {
            // declare export default [type];
            flowParseType();
            semicolon();
        }
    }
    else if (match(37392 /* _var */) || // declare export var ...
        match(34320 /* _function */) || // declare export function ...
        match(41488 /* _class */) || // declare export class ...
        isContextual(22 /* _opaque */) // declare export opaque ..
    ) {
        flowParseDeclare();
    }
    else if (match(24587 /* star */) || // declare export * from ''
        match(4096 /* braceL */) || // declare export {} ...
        isContextual(15 /* _interface */) || // declare export interface ...
        isContextual(30 /* _type */) || // declare export type ...
        isContextual(22 /* _opaque */) // declare export opaque type ...
    ) {
        parseExport();
    }
    else {
        throw unexpected();
    }
}
function flowParseDeclareModuleExports() {
    expectContextual(19 /* _module */);
    expect(9216 /* dot */);
    expectContextual(9 /* _exports */);
    flowParseTypeAnnotation();
    semicolon();
}
function flowParseDeclareTypeAlias() {
    next();
    flowParseTypeAlias();
}
function flowParseDeclareOpaqueType() {
    next();
    flowParseOpaqueType(true);
}
function flowParseDeclareInterface() {
    next();
    flowParseInterfaceish();
}
// Interfaces
function flowParseInterfaceish(isClass) {
    flowParseRestrictedIdentifier();
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    if (eat(42000 /* _extends */)) {
        do {
            flowParseInterfaceExtends();
        } while (!isClass && eat(7168 /* comma */));
    }
    if (isContextual(18 /* _mixins */)) {
        next();
        do {
            flowParseInterfaceExtends();
        } while (eat(7168 /* comma */));
    }
    if (isContextual(13 /* _implements */)) {
        next();
        do {
            flowParseInterfaceExtends();
        } while (eat(7168 /* comma */));
    }
    flowParseObjectType(true, false);
}
function flowParseInterfaceExtends() {
    flowParseQualifiedTypeIdentifier(false);
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterInstantiation();
    }
}
function flowParseInterface() {
    flowParseInterfaceish();
}
function flowParseRestrictedIdentifier() {
    parseIdentifier();
}
function flowParseTypeAlias() {
    flowParseRestrictedIdentifier();
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    flowParseTypeInitialiser(14368 /* eq */);
    semicolon();
}
function flowParseOpaqueType(declare) {
    expectContextual(30 /* _type */);
    flowParseRestrictedIdentifier();
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    // Parse the supertype
    if (match(8192 /* colon */)) {
        flowParseTypeInitialiser(8192 /* colon */);
    }
    if (!declare) {
        flowParseTypeInitialiser(14368 /* eq */);
    }
    semicolon();
}
function flowParseTypeParameter() {
    flowParseVariance();
    flowParseTypeAnnotatableIdentifier();
    if (eat(14368 /* eq */)) {
        flowParseType();
    }
}
export function flowParseTypeParameterDeclaration() {
    runInTypeContext(0, () => {
        // istanbul ignore else: this condition is already checked at all call sites
        if (match(21000 /* lessThan */) || match(28160 /* typeParameterStart */)) {
            next();
        }
        else {
            unexpected();
        }
        do {
            flowParseTypeParameter();
            if (!match(21512 /* greaterThan */)) {
                expect(7168 /* comma */);
            }
        } while (!match(21512 /* greaterThan */));
        expect(21512 /* greaterThan */);
    });
}
function flowParseTypeParameterInstantiation() {
    runInTypeContext(0, () => {
        expect(21000 /* lessThan */);
        while (!match(21512 /* greaterThan */)) {
            flowParseType();
            if (!match(21512 /* greaterThan */)) {
                expect(7168 /* comma */);
            }
        }
        expect(21512 /* greaterThan */);
    });
}
function flowParseObjectPropertyKey() {
    if (match(0 /* num */) || match(1536 /* string */)) {
        parseExprAtom();
    }
    else {
        parseIdentifier();
    }
}
function flowParseObjectTypeIndexer() {
    expect(3072 /* bracketL */);
    if (lookaheadType() === 8192 /* colon */) {
        flowParseObjectPropertyKey();
        flowParseTypeInitialiser();
    }
    else {
        flowParseType();
    }
    expect(3584 /* bracketR */);
    flowParseTypeInitialiser();
}
function flowParseObjectTypeMethodish() {
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
    }
    expect(6144 /* parenL */);
    while (!match(6656 /* parenR */) && !match(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
        if (!match(6656 /* parenR */)) {
            expect(7168 /* comma */);
        }
    }
    if (eat(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
    }
    expect(6656 /* parenR */);
    flowParseTypeInitialiser();
}
function flowParseObjectTypeCallProperty() {
    flowParseObjectTypeMethodish();
}
function flowParseObjectType(allowStatic, allowExact) {
    let endDelim;
    if (allowExact && match(4608 /* braceBarL */)) {
        expect(4608 /* braceBarL */);
        endDelim = 5632 /* braceBarR */;
    }
    else {
        expect(4096 /* braceL */);
        endDelim = 5120 /* braceR */;
    }
    while (!match(endDelim)) {
        let isStatic = false;
        if (allowStatic && isContextual(29 /* _static */) && lookaheadType() !== 8192 /* colon */) {
            next();
            isStatic = true;
        }
        flowParseVariance();
        if (match(3072 /* bracketL */)) {
            flowParseObjectTypeIndexer();
        }
        else if (match(6144 /* parenL */) || match(21000 /* lessThan */)) {
            flowParseObjectTypeCallProperty();
        }
        else {
            if (isContextual(11 /* _get */) || isContextual(28 /* _set */)) {
                const lookahead = lookaheadType();
                if (lookahead === 2048 /* name */ || lookahead === 1536 /* string */ || lookahead === 0 /* num */) {
                    next();
                }
            }
            flowParseObjectTypeProperty();
        }
        flowObjectTypeSemicolon();
    }
    expect(endDelim);
}
function flowParseObjectTypeProperty() {
    if (match(11776 /* ellipsis */)) {
        expect(11776 /* ellipsis */);
        flowParseType();
    }
    else {
        flowParseObjectPropertyKey();
        if (match(21000 /* lessThan */) || match(6144 /* parenL */)) {
            // This is a method property
            flowParseObjectTypeMethodish();
        }
        else {
            eat(9728 /* question */);
            flowParseTypeInitialiser();
        }
    }
}
function flowObjectTypeSemicolon() {
    if (!eat(7680 /* semi */) && !eat(7168 /* comma */) && !match(5120 /* braceR */) && !match(5632 /* braceBarR */)) {
        unexpected();
    }
}
function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
    if (!initialIdAlreadyParsed) {
        parseIdentifier();
    }
    while (eat(9216 /* dot */)) {
        parseIdentifier();
    }
}
function flowParseGenericType() {
    flowParseQualifiedTypeIdentifier(true);
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterInstantiation();
    }
}
function flowParseTypeofType() {
    expect(46736 /* _typeof */);
    flowParsePrimaryType();
}
function flowParseTupleType() {
    expect(3072 /* bracketL */);
    // We allow trailing commas
    while (state.pos < input.length && !match(3584 /* bracketR */)) {
        flowParseType();
        if (match(3584 /* bracketR */)) {
            break;
        }
        expect(7168 /* comma */);
    }
    expect(3584 /* bracketR */);
}
function flowParseFunctionTypeParam() {
    const lookahead = lookaheadType();
    if (lookahead === 8192 /* colon */ || lookahead === 9728 /* question */) {
        parseIdentifier();
        eat(9728 /* question */);
        flowParseTypeInitialiser();
    }
    else {
        flowParseType();
    }
}
function flowParseFunctionTypeParams() {
    while (!match(6656 /* parenR */) && !match(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
        if (!match(6656 /* parenR */)) {
            expect(7168 /* comma */);
        }
    }
    if (eat(11776 /* ellipsis */)) {
        flowParseFunctionTypeParam();
    }
}
// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
    let isGroupedType = false;
    const oldNoAnonFunctionType = state.noAnonFunctionType;
    switch (state.type) {
        case 2048 /* name */: {
            parseIdentifier();
            flowParseGenericType();
            return;
        }
        case 4096 /* braceL */:
            flowParseObjectType(false, false);
            return;
        case 4608 /* braceBarL */:
            flowParseObjectType(false, true);
            return;
        case 3072 /* bracketL */:
            flowParseTupleType();
            return;
        case 21000 /* lessThan */:
            flowParseTypeParameterDeclaration();
            expect(6144 /* parenL */);
            flowParseFunctionTypeParams();
            expect(6656 /* parenR */);
            expect(10752 /* arrow */);
            flowParseType();
            return;
        case 6144 /* parenL */:
            next();
            // Check to see if this is actually a grouped type
            if (!match(6656 /* parenR */) && !match(11776 /* ellipsis */)) {
                if (match(2048 /* name */)) {
                    const token = lookaheadType();
                    isGroupedType = token !== 9728 /* question */ && token !== 8192 /* colon */;
                }
                else {
                    isGroupedType = true;
                }
            }
            if (isGroupedType) {
                state.noAnonFunctionType = false;
                flowParseType();
                state.noAnonFunctionType = oldNoAnonFunctionType;
                // A `,` or a `) =>` means this is an anonymous function type
                if (state.noAnonFunctionType ||
                    !(match(7168 /* comma */) || (match(6656 /* parenR */) && lookaheadType() === 10752 /* arrow */))) {
                    expect(6656 /* parenR */);
                    return;
                }
                else {
                    // Eat a comma if there is one
                    eat(7168 /* comma */);
                }
            }
            flowParseFunctionTypeParams();
            expect(6656 /* parenR */);
            expect(10752 /* arrow */);
            flowParseType();
            return;
        case 23690 /* minus */:
            next();
            parseLiteral();
            return;
        case 1536 /* string */:
        case 0 /* num */:
        case 44560 /* _true */:
        case 45072 /* _false */:
        case 44048 /* _null */:
        case 40464 /* _this */:
        case 47248 /* _void */:
        case 24587 /* star */:
            next();
            return;
        default:
            if (state.type === 46736 /* _typeof */) {
                flowParseTypeofType();
                return;
            }
    }
    throw unexpected();
}
function flowParsePostfixType() {
    flowParsePrimaryType();
    while (!canInsertSemicolon() && match(3072 /* bracketL */)) {
        expect(3072 /* bracketL */);
        expect(3584 /* bracketR */);
    }
}
function flowParsePrefixType() {
    if (eat(9728 /* question */)) {
        flowParsePrefixType();
    }
    else {
        flowParsePostfixType();
    }
}
function flowParseAnonFunctionWithoutParens() {
    flowParsePrefixType();
    if (!state.noAnonFunctionType && eat(10752 /* arrow */)) {
        flowParseType();
    }
}
function flowParseIntersectionType() {
    eat(19974 /* bitwiseAND */);
    flowParseAnonFunctionWithoutParens();
    while (eat(19974 /* bitwiseAND */)) {
        flowParseAnonFunctionWithoutParens();
    }
}
function flowParseUnionType() {
    eat(18948 /* bitwiseOR */);
    flowParseIntersectionType();
    while (eat(18948 /* bitwiseOR */)) {
        flowParseIntersectionType();
    }
}
function flowParseType() {
    flowParseUnionType();
}
export function flowParseTypeAnnotation() {
    flowParseTypeInitialiser();
}
function flowParseTypeAnnotatableIdentifier() {
    parseIdentifier();
    if (match(8192 /* colon */)) {
        flowParseTypeAnnotation();
    }
}
export function flowParseVariance() {
    if (match(23178 /* plus */) || match(23690 /* minus */)) {
        next();
    }
}
// ==================================
// Overrides
// ==================================
export function flowParseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody = null, funcContextId) {
    // For arrow functions, `parseArrow` handles the return type itself.
    if (!allowExpressionBody && match(8192 /* colon */)) {
        flowParseTypeAndPredicateInitialiser();
    }
    parseFunctionBody(functionStart, isGenerator, allowExpressionBody, funcContextId);
}
// interfaces
export function flowTryParseStatement() {
    if (match(2048 /* name */) && state.contextualKeyword === 15 /* _interface */) {
        runInTypeContext(0, () => {
            next();
            flowParseInterface();
        });
        return true;
    }
    else {
        return false;
    }
}
// declares, interfaces and type aliases
export function flowParseIdentifierStatement(contextualKeyword) {
    if (contextualKeyword === 7 /* _declare */) {
        if (match(41488 /* _class */) ||
            match(2048 /* name */) ||
            match(34320 /* _function */) ||
            match(37392 /* _var */) ||
            match(42512 /* _export */)) {
            runInTypeContext(1, () => {
                flowParseDeclare();
            });
        }
    }
    else if (match(2048 /* name */)) {
        if (contextualKeyword === 15 /* _interface */) {
            runInTypeContext(1, () => {
                flowParseInterface();
            });
        }
        else if (contextualKeyword === 30 /* _type */) {
            runInTypeContext(1, () => {
                flowParseTypeAlias();
            });
        }
        else if (contextualKeyword === 22 /* _opaque */) {
            runInTypeContext(1, () => {
                flowParseOpaqueType(false);
            });
        }
    }
    semicolon();
}
// export type
export function flowShouldParseExportDeclaration() {
    return (isContextual(30 /* _type */) ||
        isContextual(15 /* _interface */) ||
        isContextual(22 /* _opaque */));
}
export function flowShouldDisallowExportDefaultSpecifier() {
    return (match(2048 /* name */) &&
        (state.contextualKeyword === 30 /* _type */ ||
            state.contextualKeyword === 15 /* _interface */ ||
            state.contextualKeyword === 22 /* _opaque */));
}
export function flowParseExportDeclaration() {
    if (isContextual(30 /* _type */)) {
        runInTypeContext(1, () => {
            next();
            if (match(4096 /* braceL */)) {
                // export type { foo, bar };
                parseExportSpecifiers();
                parseExportFrom();
            }
            else {
                // export type Foo = Bar;
                flowParseTypeAlias();
            }
        });
    }
    else if (isContextual(22 /* _opaque */)) {
        runInTypeContext(1, () => {
            next();
            // export opaque type Foo = Bar;
            flowParseOpaqueType(false);
        });
    }
    else if (isContextual(15 /* _interface */)) {
        runInTypeContext(1, () => {
            next();
            flowParseInterface();
        });
    }
    else {
        parseStatement(true);
    }
}
export function flowShouldParseExportStar() {
    return match(24587 /* star */) || (isContextual(30 /* _type */) && lookaheadType() === 24587 /* star */);
}
export function flowParseExportStar() {
    if (eatContextual(30 /* _type */)) {
        runInTypeContext(2, () => {
            baseParseExportStar();
        });
    }
    else {
        baseParseExportStar();
    }
}
// parse a the super class type parameters and implements
export function flowAfterParseClassSuper(hasSuper) {
    if (hasSuper && match(21000 /* lessThan */)) {
        flowParseTypeParameterInstantiation();
    }
    if (isContextual(13 /* _implements */)) {
        state.tokens[state.tokens.length - 1].type = 54800 /* _implements */;
        runInTypeContext(0, () => {
            next();
            do {
                flowParseRestrictedIdentifier();
                if (match(21000 /* lessThan */)) {
                    flowParseTypeParameterInstantiation();
                }
            } while (eat(7168 /* comma */));
        });
    }
}
// parse type parameters for object method shorthand
export function flowStartParseObjPropValue() {
    // method shorthand
    if (match(21000 /* lessThan */)) {
        flowParseTypeParameterDeclaration();
        if (!match(6144 /* parenL */))
            unexpected();
    }
}
export function flowParseAssignableListItemTypes() {
    runInTypeContext(0, () => {
        eat(9728 /* question */);
        if (match(8192 /* colon */)) {
            flowParseTypeAnnotation();
        }
    });
}
// parse typeof and type imports
export function flowStartParseImportSpecifiers() {
    let kind = null;
    if (match(46736 /* _typeof */)) {
        kind = "typeof";
    }
    else if (isContextual(30 /* _type */)) {
        kind = "type";
    }
    if (kind) {
        const lh = lookaheadTypeAndKeyword();
        if (isMaybeDefaultImport(lh) || lh.type === 4096 /* braceL */ || lh.type === 24587 /* star */) {
            next();
        }
    }
}
// parse import-type/typeof shorthand
export function flowParseImportSpecifier() {
    const isTypeKeyword = state.contextualKeyword === 30 /* _type */ || state.type === 46736 /* _typeof */;
    if (isTypeKeyword) {
        next();
    }
    else {
        parseIdentifier();
    }
    if (isContextual(2 /* _as */) && !isLookaheadContextual(2 /* _as */)) {
        parseIdentifier();
        if (isTypeKeyword && !match(2048 /* name */) && !(state.type & 16 /* IS_KEYWORD */)) {
            // `import {type as ,` or `import {type as }`
        }
        else {
            // `import {type as foo`
            parseIdentifier();
        }
    }
    else if (isTypeKeyword && (match(2048 /* name */) || !!(state.type & 16 /* IS_KEYWORD */))) {
        // `import {type foo`
        parseIdentifier();
        if (eatContextual(2 /* _as */)) {
            parseIdentifier();
        }
    }
}
// parse function type parameters - function foo<T>() {}
export function flowStartParseFunctionParams() {
    // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
    // anyway, so don't try to propagate that information.
    if (match(21000 /* lessThan */)) {
        runInTypeContext(0, () => {
            flowParseTypeParameterDeclaration();
        });
    }
}
// parse flow type annotations on variable declarator heads - let foo: string = bar
export function flowAfterParseVarHead() {
    if (match(8192 /* colon */)) {
        flowParseTypeAnnotation();
    }
}
// parse the return type of an async arrow function - let foo = (async (): number => {});
export function flowStartParseAsyncArrowFromCallExpression() {
    if (match(8192 /* colon */)) {
        const oldNoAnonFunctionType = state.noAnonFunctionType;
        state.noAnonFunctionType = true;
        flowParseTypeAnnotation();
        state.noAnonFunctionType = oldNoAnonFunctionType;
    }
}
// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
export function flowParseMaybeAssign(noIn, afterLeftParse) {
    let jsxError = null;
    if (match(21000 /* lessThan */)) {
        const snapshot = state.snapshot();
        try {
            return baseParseMaybeAssign(noIn, afterLeftParse);
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                state.restoreFromSnapshot(snapshot);
                state.type = 28160 /* typeParameterStart */;
                jsxError = err;
            }
            else {
                // istanbul ignore next: no such error is expected
                throw err;
            }
        }
    }
    if (jsxError != null || match(21000 /* lessThan */)) {
        let wasArrow = false;
        try {
            runInTypeContext(0, () => {
                flowParseTypeParameterDeclaration();
            });
            wasArrow = baseParseMaybeAssign(noIn, afterLeftParse);
        }
        catch (err) {
            throw jsxError || err;
        }
        if (wasArrow) {
            return true;
        }
        unexpected();
    }
    return baseParseMaybeAssign(noIn, afterLeftParse);
}
// handle return types for arrow functions
export function flowParseArrow() {
    if (match(8192 /* colon */)) {
        runInTypeContext(0, () => {
            const snapshot = state.snapshot();
            try {
                const oldNoAnonFunctionType = state.noAnonFunctionType;
                state.noAnonFunctionType = true;
                flowParseTypeAndPredicateInitialiser();
                state.noAnonFunctionType = oldNoAnonFunctionType;
                if (canInsertSemicolon())
                    unexpected();
                if (!match(10752 /* arrow */))
                    unexpected();
            }
            catch (err) {
                if (err instanceof SyntaxError) {
                    state.restoreFromSnapshot(snapshot);
                }
                else {
                    // istanbul ignore next: no such error is expected
                    throw err;
                }
            }
        });
    }
    return eat(10752 /* arrow */);
}
export function flowParseSubscripts(startPos, noCalls) {
    if (state.tokens[state.tokens.length - 1].contextualKeyword === 3 /* _async */ &&
        match(21000 /* lessThan */)) {
        const snapshot = state.snapshot();
        let error;
        try {
            const wasArrow = parseAsyncArrowWithTypeParameters(startPos);
            if (wasArrow) {
                return;
            }
        }
        catch (e) {
            error = e;
        }
        state.restoreFromSnapshot(snapshot);
        try {
            baseParseSubscripts(startPos, noCalls);
            return;
        }
        catch (e) {
            throw error || e;
        }
    }
    baseParseSubscripts(startPos, noCalls);
}
// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters(startPos) {
    const startTokenIndex = state.tokens.length;
    parseFunctionParams();
    if (!parseArrow()) {
        return false;
    }
    parseArrowExpression(startPos, startTokenIndex);
    return true;
}
