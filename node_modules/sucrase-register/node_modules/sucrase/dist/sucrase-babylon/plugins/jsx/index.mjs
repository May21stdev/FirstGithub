import { input, raise, state } from "../../parser/base";
import { parseExpression, parseMaybeAssign } from "../../parser/expression";
import { expect, unexpected } from "../../parser/util";
import { eat, finishToken, getTokenFromCode, IdentifierRole, lookaheadType, match, next, skipSpace, Token, } from "../../tokenizer";
import { isIdentifierChar, isIdentifierStart } from "../../util/identifier";
// Reads inline JSX contents token.
function jsxReadToken() {
    for (;;) {
        if (state.pos >= input.length) {
            raise(state.start, "Unterminated JSX contents");
        }
        const ch = input.charCodeAt(state.pos);
        switch (ch) {
            case 60 /* lessThan */:
            case 123 /* leftCurlyBrace */:
                if (state.pos === state.start) {
                    if (ch === 60 /* lessThan */) {
                        state.pos++;
                        finishToken(27136 /* jsxTagStart */);
                        return;
                    }
                    getTokenFromCode(ch);
                    return;
                }
                finishToken(26624 /* jsxText */);
                return;
            default:
                state.pos++;
        }
    }
}
function jsxReadString(quote) {
    state.pos++;
    for (;;) {
        if (state.pos >= input.length) {
            raise(state.start, "Unterminated string constant");
        }
        const ch = input.charCodeAt(state.pos);
        if (ch === quote) {
            state.pos++;
            break;
        }
        state.pos++;
    }
    finishToken(1536 /* string */);
}
// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.
function jsxReadWord() {
    let ch;
    do {
        ch = input.charCodeAt(++state.pos);
    } while (isIdentifierChar(ch) || ch === 45 /* dash */);
    finishToken(26112 /* jsxName */);
}
// Parse next token as JSX identifier
function jsxParseIdentifier() {
    nextJSXTagToken();
}
// Parse namespaced identifier.
function jsxParseNamespacedName() {
    jsxParseIdentifier();
    if (!eat(8192 /* colon */)) {
        // Plain identifier, so this is an access.
        state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;
        return;
    }
    // Process the second half of the namespaced name.
    jsxParseIdentifier();
}
// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
    jsxParseNamespacedName();
    while (match(9216 /* dot */)) {
        nextJSXTagToken();
        jsxParseIdentifier();
    }
}
// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
    switch (state.type) {
        case 4096 /* braceL */:
            jsxParseExpressionContainer();
            nextJSXTagToken();
            return;
        case 27136 /* jsxTagStart */:
            jsxParseElement();
            nextJSXTagToken();
            return;
        case 1536 /* string */:
            nextJSXTagToken();
            return;
        default:
            throw raise(state.start, "JSX value should be either an expression or a quoted JSX text");
    }
}
function jsxParseEmptyExpression() {
    // Do nothing.
}
// Parse JSX spread child
function jsxParseSpreadChild() {
    expect(4096 /* braceL */);
    expect(11776 /* ellipsis */);
    parseExpression();
    expect(5120 /* braceR */);
}
// Parses JSX expression enclosed into curly brackets.
// Does not parse the last token.
function jsxParseExpressionContainer() {
    next();
    if (match(5120 /* braceR */)) {
        jsxParseEmptyExpression();
    }
    else {
        parseExpression();
    }
}
// Parses following JSX attribute name-value pair.
function jsxParseAttribute() {
    if (eat(4096 /* braceL */)) {
        expect(11776 /* ellipsis */);
        parseMaybeAssign();
        // }
        nextJSXTagToken();
        return;
    }
    jsxParseNamespacedName();
    if (match(14368 /* eq */)) {
        nextJSXTagToken();
        jsxParseAttributeValue();
    }
}
// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement() {
    if (match(27648 /* jsxTagEnd */)) {
        nextJSXExprToken();
        // This is an open-fragment.
        return false;
    }
    jsxParseElementName();
    while (!match(25099 /* slash */) && !match(27648 /* jsxTagEnd */)) {
        jsxParseAttribute();
    }
    const isSelfClosing = match(25099 /* slash */);
    if (isSelfClosing) {
        // /
        nextJSXTagToken();
    }
    return isSelfClosing;
}
// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
    if (eat(27648 /* jsxTagEnd */)) {
        return;
    }
    jsxParseElementName();
}
// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
    const isSelfClosing = jsxParseOpeningElement();
    if (!isSelfClosing) {
        nextJSXExprToken();
        contents: while (true) {
            switch (state.type) {
                case 27136 /* jsxTagStart */:
                    nextJSXTagToken();
                    if (match(25099 /* slash */)) {
                        nextJSXTagToken();
                        jsxParseClosingElement();
                        break contents;
                    }
                    jsxParseElementAt();
                    nextJSXExprToken();
                    break;
                case 26624 /* jsxText */:
                    nextJSXExprToken();
                    break;
                case 4096 /* braceL */:
                    if (lookaheadType() === 11776 /* ellipsis */) {
                        jsxParseSpreadChild();
                    }
                    else {
                        jsxParseExpressionContainer();
                        nextJSXExprToken();
                    }
                    break;
                // istanbul ignore next - should never happen
                default:
                    throw unexpected();
            }
        }
    }
}
// Parses entire JSX element from current position.
// Does not parse the last token.
export function jsxParseElement() {
    nextJSXTagToken();
    jsxParseElementAt();
}
// ==================================
// Overrides
// ==================================
function nextJSXTagToken() {
    state.tokens.push(new Token());
    skipSpace();
    state.start = state.pos;
    const code = input.charCodeAt(state.pos);
    if (isIdentifierStart(code)) {
        jsxReadWord();
    }
    else if (code === 34 /* quotationMark */ || code === 39 /* apostrophe */) {
        jsxReadString(code);
    }
    else {
        // The following tokens are just one character each.
        ++state.pos;
        switch (code) {
            case 62 /* greaterThan */:
                finishToken(27648 /* jsxTagEnd */);
                break;
            case 47 /* slash */:
                finishToken(25099 /* slash */);
                break;
            case 61 /* equalsTo */:
                finishToken(14368 /* eq */);
                break;
            case 123 /* leftCurlyBrace */:
                finishToken(4096 /* braceL */);
                break;
            case 46 /* dot */:
                finishToken(9216 /* dot */);
                break;
            case 58 /* colon */:
                finishToken(8192 /* colon */);
                break;
            default:
                unexpected();
        }
    }
}
function nextJSXExprToken() {
    state.tokens.push(new Token());
    state.start = state.pos;
    jsxReadToken();
}
