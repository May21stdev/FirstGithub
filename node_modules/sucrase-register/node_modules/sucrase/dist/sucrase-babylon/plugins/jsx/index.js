"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../../parser/base");
const expression_1 = require("../../parser/expression");
const util_1 = require("../../parser/util");
const tokenizer_1 = require("../../tokenizer");
const identifier_1 = require("../../util/identifier");
// Reads inline JSX contents token.
function jsxReadToken() {
    for (;;) {
        if (base_1.state.pos >= base_1.input.length) {
            base_1.raise(base_1.state.start, "Unterminated JSX contents");
        }
        const ch = base_1.input.charCodeAt(base_1.state.pos);
        switch (ch) {
            case 60 /* lessThan */:
            case 123 /* leftCurlyBrace */:
                if (base_1.state.pos === base_1.state.start) {
                    if (ch === 60 /* lessThan */) {
                        base_1.state.pos++;
                        tokenizer_1.finishToken(27136 /* jsxTagStart */);
                        return;
                    }
                    tokenizer_1.getTokenFromCode(ch);
                    return;
                }
                tokenizer_1.finishToken(26624 /* jsxText */);
                return;
            default:
                base_1.state.pos++;
        }
    }
}
function jsxReadString(quote) {
    base_1.state.pos++;
    for (;;) {
        if (base_1.state.pos >= base_1.input.length) {
            base_1.raise(base_1.state.start, "Unterminated string constant");
        }
        const ch = base_1.input.charCodeAt(base_1.state.pos);
        if (ch === quote) {
            base_1.state.pos++;
            break;
        }
        base_1.state.pos++;
    }
    tokenizer_1.finishToken(1536 /* string */);
}
// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.
function jsxReadWord() {
    let ch;
    do {
        ch = base_1.input.charCodeAt(++base_1.state.pos);
    } while (identifier_1.isIdentifierChar(ch) || ch === 45 /* dash */);
    tokenizer_1.finishToken(26112 /* jsxName */);
}
// Parse next token as JSX identifier
function jsxParseIdentifier() {
    nextJSXTagToken();
}
// Parse namespaced identifier.
function jsxParseNamespacedName() {
    jsxParseIdentifier();
    if (!tokenizer_1.eat(8192 /* colon */)) {
        // Plain identifier, so this is an access.
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.Access;
        return;
    }
    // Process the second half of the namespaced name.
    jsxParseIdentifier();
}
// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
    jsxParseNamespacedName();
    while (tokenizer_1.match(9216 /* dot */)) {
        nextJSXTagToken();
        jsxParseIdentifier();
    }
}
// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
    switch (base_1.state.type) {
        case 4096 /* braceL */:
            jsxParseExpressionContainer();
            nextJSXTagToken();
            return;
        case 27136 /* jsxTagStart */:
            jsxParseElement();
            nextJSXTagToken();
            return;
        case 1536 /* string */:
            nextJSXTagToken();
            return;
        default:
            throw base_1.raise(base_1.state.start, "JSX value should be either an expression or a quoted JSX text");
    }
}
function jsxParseEmptyExpression() {
    // Do nothing.
}
// Parse JSX spread child
function jsxParseSpreadChild() {
    util_1.expect(4096 /* braceL */);
    util_1.expect(11776 /* ellipsis */);
    expression_1.parseExpression();
    util_1.expect(5120 /* braceR */);
}
// Parses JSX expression enclosed into curly brackets.
// Does not parse the last token.
function jsxParseExpressionContainer() {
    tokenizer_1.next();
    if (tokenizer_1.match(5120 /* braceR */)) {
        jsxParseEmptyExpression();
    }
    else {
        expression_1.parseExpression();
    }
}
// Parses following JSX attribute name-value pair.
function jsxParseAttribute() {
    if (tokenizer_1.eat(4096 /* braceL */)) {
        util_1.expect(11776 /* ellipsis */);
        expression_1.parseMaybeAssign();
        // }
        nextJSXTagToken();
        return;
    }
    jsxParseNamespacedName();
    if (tokenizer_1.match(14368 /* eq */)) {
        nextJSXTagToken();
        jsxParseAttributeValue();
    }
}
// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement() {
    if (tokenizer_1.match(27648 /* jsxTagEnd */)) {
        nextJSXExprToken();
        // This is an open-fragment.
        return false;
    }
    jsxParseElementName();
    while (!tokenizer_1.match(25099 /* slash */) && !tokenizer_1.match(27648 /* jsxTagEnd */)) {
        jsxParseAttribute();
    }
    const isSelfClosing = tokenizer_1.match(25099 /* slash */);
    if (isSelfClosing) {
        // /
        nextJSXTagToken();
    }
    return isSelfClosing;
}
// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
    if (tokenizer_1.eat(27648 /* jsxTagEnd */)) {
        return;
    }
    jsxParseElementName();
}
// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
    const isSelfClosing = jsxParseOpeningElement();
    if (!isSelfClosing) {
        nextJSXExprToken();
        contents: while (true) {
            switch (base_1.state.type) {
                case 27136 /* jsxTagStart */:
                    nextJSXTagToken();
                    if (tokenizer_1.match(25099 /* slash */)) {
                        nextJSXTagToken();
                        jsxParseClosingElement();
                        break contents;
                    }
                    jsxParseElementAt();
                    nextJSXExprToken();
                    break;
                case 26624 /* jsxText */:
                    nextJSXExprToken();
                    break;
                case 4096 /* braceL */:
                    if (tokenizer_1.lookaheadType() === 11776 /* ellipsis */) {
                        jsxParseSpreadChild();
                    }
                    else {
                        jsxParseExpressionContainer();
                        nextJSXExprToken();
                    }
                    break;
                // istanbul ignore next - should never happen
                default:
                    throw util_1.unexpected();
            }
        }
    }
}
// Parses entire JSX element from current position.
// Does not parse the last token.
function jsxParseElement() {
    nextJSXTagToken();
    jsxParseElementAt();
}
exports.jsxParseElement = jsxParseElement;
// ==================================
// Overrides
// ==================================
function nextJSXTagToken() {
    base_1.state.tokens.push(new tokenizer_1.Token());
    tokenizer_1.skipSpace();
    base_1.state.start = base_1.state.pos;
    const code = base_1.input.charCodeAt(base_1.state.pos);
    if (identifier_1.isIdentifierStart(code)) {
        jsxReadWord();
    }
    else if (code === 34 /* quotationMark */ || code === 39 /* apostrophe */) {
        jsxReadString(code);
    }
    else {
        // The following tokens are just one character each.
        ++base_1.state.pos;
        switch (code) {
            case 62 /* greaterThan */:
                tokenizer_1.finishToken(27648 /* jsxTagEnd */);
                break;
            case 47 /* slash */:
                tokenizer_1.finishToken(25099 /* slash */);
                break;
            case 61 /* equalsTo */:
                tokenizer_1.finishToken(14368 /* eq */);
                break;
            case 123 /* leftCurlyBrace */:
                tokenizer_1.finishToken(4096 /* braceL */);
                break;
            case 46 /* dot */:
                tokenizer_1.finishToken(9216 /* dot */);
                break;
            case 58 /* colon */:
                tokenizer_1.finishToken(8192 /* colon */);
                break;
            default:
                util_1.unexpected();
        }
    }
}
function nextJSXExprToken() {
    base_1.state.tokens.push(new tokenizer_1.Token());
    base_1.state.start = base_1.state.pos;
    jsxReadToken();
}
