/* eslint max-len: 0 */
import { flowAfterParseClassSuper, flowAfterParseVarHead, flowParseExportDeclaration, flowParseExportStar, flowParseIdentifierStatement, flowParseImportSpecifier, flowParseTypeAnnotation, flowParseTypeParameterDeclaration, flowShouldDisallowExportDefaultSpecifier, flowShouldParseExportDeclaration, flowShouldParseExportStar, flowStartParseFunctionParams, flowStartParseImportSpecifiers, flowTryParseStatement, } from "../plugins/flow";
import { tsAfterParseClassSuper, tsAfterParseVarHead, tsIsDeclarationStart, tsParseAccessModifier, tsParseExportDeclaration, tsParseIdentifierStatement, tsParseImportEqualsDeclaration, tsStartParseFunctionParams, tsTryParseClassMemberWithIsStatic, tsTryParseExport, tsTryParseExportDefaultExpression, tsTryParseStatementContent, tsTryParseTypeAnnotation, tsTryParseTypeParameters, } from "../plugins/typescript";
import { eat, IdentifierRole, lookaheadType, lookaheadTypeAndKeyword, match, next, } from "../tokenizer";
import { getNextContextId, hasPlugin, state } from "./base";
import { parseCallExpressionArguments, parseExprAtom, parseExpression, parseExprSubscripts, parseFunctionBodyAndFinish, parseIdentifier, parseMaybeAssign, parseMethod, parseParenExpression, parsePropertyName, } from "./expression";
import { parseBindingAtom, parseBindingIdentifier, parseBindingList } from "./lval";
import { canInsertSemicolon, eatContextual, expect, expectContextual, isContextual, isLineTerminator, semicolon, unexpected, } from "./util";
export function parseTopLevel() {
    parseBlockBody(true, 2560 /* eof */);
    state.scopes.push({
        startTokenIndex: 0,
        endTokenIndex: state.tokens.length,
        isFunctionScope: true,
    });
    return {
        tokens: state.tokens,
        scopes: state.scopes,
    };
}
// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.
export function parseStatement(declaration, topLevel = false) {
    if (hasPlugin("flow")) {
        if (flowTryParseStatement()) {
            return;
        }
    }
    if (match(13312 /* at */)) {
        parseDecorators();
    }
    parseStatementContent(declaration, topLevel);
}
function parseStatementContent(declaration, topLevel) {
    if (hasPlugin("typescript")) {
        if (tsTryParseStatementContent()) {
            return;
        }
    }
    const starttype = state.type;
    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.
    switch (starttype) {
        case 29200 /* _break */:
        case 30736 /* _continue */:
            parseBreakContinueStatement();
            return;
        case 31248 /* _debugger */:
            parseDebuggerStatement();
            return;
        case 32272 /* _do */:
            parseDoStatement();
            return;
        case 33808 /* _for */:
            parseForStatement();
            return;
        case 34320 /* _function */:
            if (lookaheadType() === 9216 /* dot */)
                break;
            if (!declaration)
                unexpected();
            parseFunctionStatement();
            return;
        case 41488 /* _class */:
            if (!declaration)
                unexpected();
            parseClass(true);
            return;
        case 34832 /* _if */:
            parseIfStatement();
            return;
        case 35344 /* _return */:
            parseReturnStatement();
            return;
        case 35856 /* _switch */:
            parseSwitchStatement();
            return;
        case 36496 /* _throw */:
            parseThrowStatement();
            return;
        case 36880 /* _try */:
            parseTryStatement();
            return;
        case 37904 /* _let */:
        case 38416 /* _const */:
            if (!declaration)
                unexpected(); // NOTE: falls through to _var
        case 37392 /* _var */:
            parseVarStatement(starttype);
            return;
        case 38928 /* _while */:
            parseWhileStatement();
            return;
        case 4096 /* braceL */:
            parseBlock();
            return;
        case 7680 /* semi */:
            parseEmptyStatement();
            return;
        case 42512 /* _export */:
        case 43024 /* _import */: {
            const nextType = lookaheadType();
            if (nextType === 6144 /* parenL */ || nextType === 9216 /* dot */) {
                break;
            }
            next();
            if (starttype === 43024 /* _import */) {
                parseImport();
            }
            else {
                parseExport();
            }
            return;
        }
        case 2048 /* name */:
            if (state.contextualKeyword === 3 /* _async */) {
                const functionStart = state.start;
                // peek ahead and see if next token is a function
                const snapshot = state.snapshot();
                next();
                if (match(34320 /* _function */) && !canInsertSemicolon()) {
                    expect(34320 /* _function */);
                    parseFunction(functionStart, true, false);
                    return;
                }
                else {
                    state.restoreFromSnapshot(snapshot);
                }
            }
        default:
            // Do nothing.
            break;
    }
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    const initialTokensLength = state.tokens.length;
    parseExpression();
    let simpleName = null;
    if (state.tokens.length === initialTokensLength + 1) {
        const token = state.tokens[state.tokens.length - 1];
        if (token.type === 2048 /* name */) {
            simpleName = token.contextualKeyword;
        }
    }
    if (simpleName == null) {
        semicolon();
        return;
    }
    if (eat(8192 /* colon */)) {
        parseLabeledStatement();
    }
    else {
        // This was an identifier, so we might want to handle flow/typescript-specific cases.
        parseIdentifierStatement(simpleName);
    }
}
export function parseDecorators() {
    while (match(13312 /* at */)) {
        parseDecorator();
    }
}
function parseDecorator() {
    next();
    if (eat(6144 /* parenL */)) {
        parseExpression();
        expect(6656 /* parenR */);
    }
    else {
        parseIdentifier();
        while (eat(9216 /* dot */)) {
            parseIdentifier();
        }
    }
    if (eat(6144 /* parenL */)) {
        parseCallExpressionArguments(6656 /* parenR */);
    }
}
function parseBreakContinueStatement() {
    next();
    if (!isLineTerminator()) {
        parseIdentifier();
        semicolon();
    }
}
function parseDebuggerStatement() {
    next();
    semicolon();
}
function parseDoStatement() {
    next();
    parseStatement(false);
    expect(38928 /* _while */);
    parseParenExpression();
    eat(7680 /* semi */);
}
function parseForStatement() {
    const startTokenIndex = state.tokens.length;
    parseAmbiguousForStatement();
    const endTokenIndex = state.tokens.length;
    state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: false });
}
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
function parseAmbiguousForStatement() {
    next();
    let forAwait = false;
    if (isContextual(4 /* _await */)) {
        forAwait = true;
        next();
    }
    expect(6144 /* parenL */);
    if (match(7680 /* semi */)) {
        if (forAwait) {
            unexpected();
        }
        parseFor();
        return;
    }
    if (match(37392 /* _var */) || match(37904 /* _let */) || match(38416 /* _const */)) {
        const varKind = state.type;
        next();
        parseVar(true, varKind);
        if (match(45592 /* _in */) || isContextual(21 /* _of */)) {
            parseForIn(forAwait);
            return;
        }
        parseFor();
        return;
    }
    parseExpression(true);
    if (match(45592 /* _in */) || isContextual(21 /* _of */)) {
        parseForIn(forAwait);
        return;
    }
    if (forAwait) {
        unexpected();
    }
    parseFor();
}
function parseFunctionStatement() {
    const functionStart = state.start;
    next();
    parseFunction(functionStart, true);
}
function parseIfStatement() {
    next();
    parseParenExpression();
    parseStatement(false);
    if (eat(32784 /* _else */)) {
        parseStatement(false);
    }
}
function parseReturnStatement() {
    next();
    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.
    if (!isLineTerminator()) {
        parseExpression();
        semicolon();
    }
}
function parseSwitchStatement() {
    next();
    parseParenExpression();
    const startTokenIndex = state.tokens.length;
    expect(4096 /* braceL */);
    // Don't bother validation; just go through any sequence of cases, defaults, and statements.
    while (!match(5120 /* braceR */)) {
        if (match(29712 /* _case */) || match(31760 /* _default */)) {
            const isCase = match(29712 /* _case */);
            next();
            if (isCase) {
                parseExpression();
            }
            expect(8192 /* colon */);
        }
        else {
            parseStatement(true);
        }
    }
    next(); // Closing brace
    const endTokenIndex = state.tokens.length;
    state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: false });
}
function parseThrowStatement() {
    next();
    parseExpression();
    semicolon();
}
function parseTryStatement() {
    next();
    parseBlock();
    if (match(30224 /* _catch */)) {
        next();
        let catchBindingStartTokenIndex = null;
        if (match(6144 /* parenL */)) {
            catchBindingStartTokenIndex = state.tokens.length;
            expect(6144 /* parenL */);
            parseBindingAtom(true /* isBlockScope */);
            expect(6656 /* parenR */);
        }
        parseBlock();
        if (catchBindingStartTokenIndex != null) {
            // We need a special scope for the catch binding which includes the binding itself and the
            // catch block.
            const endTokenIndex = state.tokens.length;
            state.scopes.push({
                startTokenIndex: catchBindingStartTokenIndex,
                endTokenIndex,
                isFunctionScope: false,
            });
        }
    }
    if (eat(33296 /* _finally */)) {
        parseBlock();
    }
}
export function parseVarStatement(kind) {
    next();
    parseVar(false, kind);
    semicolon();
}
function parseWhileStatement() {
    next();
    parseParenExpression();
    parseStatement(false);
}
function parseEmptyStatement() {
    next();
}
function parseLabeledStatement() {
    parseStatement(true);
}
/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */
function parseIdentifierStatement(contextualKeyword) {
    if (hasPlugin("typescript")) {
        tsParseIdentifierStatement(contextualKeyword);
    }
    else if (hasPlugin("flow")) {
        flowParseIdentifierStatement(contextualKeyword);
    }
    else {
        semicolon();
    }
}
// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).
export function parseBlock(allowDirectives = false, isFunctionScope = false, contextId) {
    const startTokenIndex = state.tokens.length;
    expect(4096 /* braceL */);
    if (contextId) {
        state.tokens[state.tokens.length - 1].contextId = contextId;
    }
    parseBlockBody(false, 5120 /* braceR */);
    if (contextId) {
        state.tokens[state.tokens.length - 1].contextId = contextId;
    }
    const endTokenIndex = state.tokens.length;
    state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope });
}
export function parseBlockBody(topLevel, end) {
    while (!eat(end)) {
        parseStatement(true, topLevel);
    }
}
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
function parseFor() {
    expect(7680 /* semi */);
    if (!match(7680 /* semi */)) {
        parseExpression();
    }
    expect(7680 /* semi */);
    if (!match(6656 /* parenR */)) {
        parseExpression();
    }
    expect(6656 /* parenR */);
    parseStatement(false);
}
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
function parseForIn(forAwait) {
    if (forAwait) {
        eatContextual(21 /* _of */);
    }
    else {
        next();
    }
    parseExpression();
    expect(6656 /* parenR */);
    parseStatement(false);
}
// Parse a list of variable declarations.
function parseVar(isFor, kind) {
    while (true) {
        const isBlockScope = kind === 38416 /* _const */ || kind === 37904 /* _let */;
        parseVarHead(isBlockScope);
        if (eat(14368 /* eq */)) {
            parseMaybeAssign(isFor);
        }
        if (!eat(7168 /* comma */))
            break;
    }
}
function parseVarHead(isBlockScope) {
    parseBindingAtom(isBlockScope);
    if (hasPlugin("typescript")) {
        tsAfterParseVarHead();
    }
    else if (hasPlugin("flow")) {
        flowAfterParseVarHead();
    }
}
// Parse a function declaration or literal (depending on the
// `isStatement` parameter).
export function parseFunction(functionStart, isStatement, allowExpressionBody, optionalId) {
    let isGenerator = false;
    if (match(24587 /* star */)) {
        isGenerator = true;
        next();
    }
    if (isStatement && !optionalId && !match(2048 /* name */) && !match(43536 /* _yield */)) {
        unexpected();
    }
    let nameScopeStartTokenIndex = null;
    if (match(2048 /* name */)) {
        // Expression-style functions should limit their name's scope to the function body, so we make
        // a new function scope to enforce that.
        if (!isStatement) {
            nameScopeStartTokenIndex = state.tokens.length;
        }
        parseBindingIdentifier();
        state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.FunctionScopedDeclaration;
    }
    const startTokenIndex = state.tokens.length;
    parseFunctionParams();
    parseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody);
    const endTokenIndex = state.tokens.length;
    // In addition to the block scope of the function body, we need a separate function-style scope
    // that includes the params.
    state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: true });
    if (nameScopeStartTokenIndex !== null) {
        state.scopes.push({
            startTokenIndex: nameScopeStartTokenIndex,
            endTokenIndex,
            isFunctionScope: true,
        });
    }
}
export function parseFunctionParams(allowModifiers, funcContextId) {
    if (hasPlugin("typescript")) {
        tsStartParseFunctionParams();
    }
    else if (hasPlugin("flow")) {
        flowStartParseFunctionParams();
    }
    expect(6144 /* parenL */);
    if (funcContextId) {
        state.tokens[state.tokens.length - 1].contextId = funcContextId;
    }
    parseBindingList(6656 /* parenR */, false /* isBlockScope */, false /* allowEmpty */, allowModifiers);
    if (funcContextId) {
        state.tokens[state.tokens.length - 1].contextId = funcContextId;
    }
}
// Parse a class declaration or literal (depending on the
// `isStatement` parameter).
export function parseClass(isStatement, optionalId = false) {
    // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
    // code can easily navigate to meaningful points on the class.
    const contextId = getNextContextId();
    next();
    state.tokens[state.tokens.length - 1].contextId = contextId;
    state.tokens[state.tokens.length - 1].isExpression = !isStatement;
    // Like with functions, we declare a special "name scope" from the start of the name to the end
    // of the class, but only with expression-style classes, to represent the fact that the name is
    // available to the body of the class but not an outer declaration.
    let nameScopeStartTokenIndex = null;
    if (!isStatement) {
        nameScopeStartTokenIndex = state.tokens.length;
    }
    parseClassId(isStatement, optionalId);
    parseClassSuper();
    const openBraceIndex = state.tokens.length;
    parseClassBody(contextId);
    state.tokens[openBraceIndex].contextId = contextId;
    state.tokens[state.tokens.length - 1].contextId = contextId;
    if (nameScopeStartTokenIndex !== null) {
        const endTokenIndex = state.tokens.length;
        state.scopes.push({
            startTokenIndex: nameScopeStartTokenIndex,
            endTokenIndex,
            isFunctionScope: false,
        });
    }
}
function isClassProperty() {
    return match(14368 /* eq */) || match(7680 /* semi */) || match(5120 /* braceR */) || match(16000 /* bang */) || match(8192 /* colon */);
}
function isClassMethod() {
    return match(6144 /* parenL */) || match(21000 /* lessThan */);
}
function parseClassBody(classContextId) {
    expect(4096 /* braceL */);
    while (!eat(5120 /* braceR */)) {
        if (eat(7680 /* semi */)) {
            continue;
        }
        if (match(13312 /* at */)) {
            parseDecorator();
            continue;
        }
        const memberStart = state.start;
        parseClassMember(memberStart, classContextId);
    }
}
function parseClassMember(memberStart, classContextId) {
    if (hasPlugin("typescript")) {
        tsParseAccessModifier();
    }
    let isStatic = false;
    if (match(2048 /* name */) && state.contextualKeyword === 29 /* _static */) {
        parseIdentifier(); // eats 'static'
        if (isClassMethod()) {
            parseClassMethod(memberStart, false, /* isConstructor */ false);
            return;
        }
        else if (isClassProperty()) {
            parseClassProperty();
            return;
        }
        // otherwise something static
        state.tokens[state.tokens.length - 1].type = 51216 /* _static */;
        isStatic = true;
    }
    parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}
function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
    if (hasPlugin("typescript")) {
        if (tsTryParseClassMemberWithIsStatic(isStatic, classContextId)) {
            return;
        }
    }
    if (eat(24587 /* star */)) {
        // a generator
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, true, /* isConstructor */ false);
        return;
    }
    // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
    // "set".
    parseClassPropertyName(classContextId);
    let isConstructor = false;
    const token = state.tokens[state.tokens.length - 1];
    // We allow "constructor" as either an identifier or a string.
    if (token.contextualKeyword === 6 /* _constructor */) {
        isConstructor = true;
    }
    parsePostMemberNameModifiers();
    if (isClassMethod()) {
        parseClassMethod(memberStart, false, isConstructor);
    }
    else if (isClassProperty()) {
        parseClassProperty();
    }
    else if (token.contextualKeyword === 3 /* _async */ && !isLineTerminator()) {
        state.tokens[state.tokens.length - 1].type = 48144 /* _async */;
        // an async method
        const isGenerator = match(24587 /* star */);
        if (isGenerator) {
            next();
        }
        // The so-called parsed name would have been "async": get the real name.
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, isGenerator, false /* isConstructor */);
    }
    else if ((token.contextualKeyword === 11 /* _get */ ||
        token.contextualKeyword === 28 /* _set */) &&
        !(isLineTerminator() && match(24587 /* star */))) {
        if (token.contextualKeyword === 11 /* _get */) {
            state.tokens[state.tokens.length - 1].type = 48656 /* _get */;
        }
        else {
            state.tokens[state.tokens.length - 1].type = 49168 /* _set */;
        }
        // `get\n*` is an uninitialized property named 'get' followed by a generator.
        // a getter or setter
        // The so-called parsed name would have been "get/set": get the real name.
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, false, /* isConstructor */ false);
    }
    else if (isLineTerminator()) {
        // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
        parseClassProperty();
    }
    else {
        unexpected();
    }
}
function parseClassMethod(functionStart, isGenerator, isConstructor) {
    if (hasPlugin("typescript")) {
        tsTryParseTypeParameters();
    }
    else if (hasPlugin("flow")) {
        if (match(21000 /* lessThan */)) {
            flowParseTypeParameterDeclaration();
        }
    }
    parseMethod(functionStart, isGenerator, isConstructor);
}
// Return the name of the class property, if it is a simple identifier.
export function parseClassPropertyName(classContextId) {
    parsePropertyName(classContextId);
}
export function parsePostMemberNameModifiers() {
    if (hasPlugin("typescript")) {
        eat(9728 /* question */);
    }
}
export function parseClassProperty() {
    if (hasPlugin("typescript")) {
        eat(16000 /* bang */);
        tsTryParseTypeAnnotation();
    }
    else if (hasPlugin("flow")) {
        if (match(8192 /* colon */)) {
            flowParseTypeAnnotation();
        }
    }
    if (match(14368 /* eq */)) {
        const equalsTokenIndex = state.tokens.length;
        next();
        parseMaybeAssign();
        state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;
    }
    semicolon();
}
function parseClassId(isStatement, optionalId = false) {
    if (hasPlugin("typescript") &&
        (!isStatement || optionalId) &&
        isContextual(13 /* _implements */)) {
        return;
    }
    if (match(2048 /* name */)) {
        parseIdentifier();
        state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.BlockScopedDeclaration;
    }
    if (hasPlugin("typescript")) {
        tsTryParseTypeParameters();
    }
    else if (hasPlugin("flow")) {
        if (match(21000 /* lessThan */)) {
            flowParseTypeParameterDeclaration();
        }
    }
}
// Returns true if there was a superclass.
function parseClassSuper() {
    let hasSuper;
    if (eat(42000 /* _extends */)) {
        parseExprSubscripts();
        hasSuper = true;
    }
    else {
        hasSuper = false;
    }
    if (hasPlugin("typescript")) {
        tsAfterParseClassSuper(hasSuper);
    }
    else if (hasPlugin("flow")) {
        flowAfterParseClassSuper(hasSuper);
    }
}
// Parses module export declaration.
export function parseExport() {
    if (hasPlugin("typescript")) {
        if (tsTryParseExport()) {
            return;
        }
    }
    // export * from '...'
    if (shouldParseExportStar()) {
        parseExportStar();
    }
    else if (isExportDefaultSpecifier()) {
        // export default from
        parseIdentifier();
        if (match(7168 /* comma */) && lookaheadType() === 24587 /* star */) {
            expect(7168 /* comma */);
            expect(24587 /* star */);
            expectContextual(2 /* _as */);
            parseIdentifier();
        }
        else {
            parseExportSpecifiersMaybe();
        }
        parseExportFrom();
    }
    else if (eat(31760 /* _default */)) {
        // export default ...
        parseExportDefaultExpression();
    }
    else if (shouldParseExportDeclaration()) {
        parseExportDeclaration();
    }
    else {
        // export { x, y as z } [from '...']
        parseExportSpecifiers();
        parseExportFrom();
    }
}
function parseExportDefaultExpression() {
    if (hasPlugin("typescript")) {
        if (tsTryParseExportDefaultExpression()) {
            return;
        }
    }
    const functionStart = state.start;
    if (eat(34320 /* _function */)) {
        parseFunction(functionStart, true, false, true);
    }
    else if (isContextual(3 /* _async */) && lookaheadType() === 34320 /* _function */) {
        // async function declaration
        eatContextual(3 /* _async */);
        eat(34320 /* _function */);
        parseFunction(functionStart, true, false, true);
    }
    else if (match(41488 /* _class */)) {
        parseClass(true, true);
    }
    else if (match(13312 /* at */)) {
        parseDecorators();
        parseClass(true, true);
    }
    else {
        parseMaybeAssign();
        semicolon();
    }
}
function parseExportDeclaration() {
    if (hasPlugin("typescript")) {
        tsParseExportDeclaration();
    }
    else if (hasPlugin("flow")) {
        flowParseExportDeclaration();
    }
    else {
        parseStatement(true);
    }
}
function isExportDefaultSpecifier() {
    if (hasPlugin("typescript") && tsIsDeclarationStart()) {
        return false;
    }
    else if (hasPlugin("flow") && flowShouldDisallowExportDefaultSpecifier()) {
        return false;
    }
    if (match(2048 /* name */)) {
        return state.contextualKeyword !== 3 /* _async */;
    }
    if (!match(31760 /* _default */)) {
        return false;
    }
    const lookahead = lookaheadTypeAndKeyword();
    return (lookahead.type === 7168 /* comma */ ||
        (lookahead.type === 2048 /* name */ && lookahead.contextualKeyword === 10 /* _from */));
}
function parseExportSpecifiersMaybe() {
    if (eat(7168 /* comma */)) {
        parseExportSpecifiers();
    }
}
export function parseExportFrom() {
    if (eatContextual(10 /* _from */)) {
        parseExprAtom();
    }
    semicolon();
}
function shouldParseExportStar() {
    if (hasPlugin("flow")) {
        return flowShouldParseExportStar();
    }
    else {
        return match(24587 /* star */);
    }
}
function parseExportStar() {
    if (hasPlugin("flow")) {
        flowParseExportStar();
    }
    else {
        baseParseExportStar();
    }
}
export function baseParseExportStar() {
    expect(24587 /* star */);
    if (isContextual(2 /* _as */)) {
        parseExportNamespace();
    }
    else {
        parseExportFrom();
    }
}
function parseExportNamespace() {
    next();
    state.tokens[state.tokens.length - 1].type = 53264 /* _as */;
    parseIdentifier();
    parseExportSpecifiersMaybe();
    parseExportFrom();
}
function shouldParseExportDeclaration() {
    return ((hasPlugin("typescript") && tsIsDeclarationStart()) ||
        (hasPlugin("flow") && flowShouldParseExportDeclaration()) ||
        state.type === 37392 /* _var */ ||
        state.type === 38416 /* _const */ ||
        state.type === 37904 /* _let */ ||
        state.type === 34320 /* _function */ ||
        state.type === 41488 /* _class */ ||
        isContextual(3 /* _async */) ||
        match(13312 /* at */));
}
// Parses a comma-separated list of module exports.
export function parseExportSpecifiers() {
    let first = true;
    // export { x, y as z } [from '...']
    expect(4096 /* braceL */);
    while (!eat(5120 /* braceR */)) {
        if (first) {
            first = false;
        }
        else {
            expect(7168 /* comma */);
            if (eat(5120 /* braceR */))
                break;
        }
        parseIdentifier();
        state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
        if (eatContextual(2 /* _as */)) {
            parseIdentifier();
        }
    }
}
// Parses import declaration.
export function parseImport() {
    if (hasPlugin("typescript") && match(2048 /* name */) && lookaheadType() === 14368 /* eq */) {
        tsParseImportEqualsDeclaration();
        return;
    }
    // import '...'
    if (match(1536 /* string */)) {
        parseExprAtom();
    }
    else {
        parseImportSpecifiers();
        expectContextual(10 /* _from */);
        parseExprAtom();
    }
    semicolon();
}
// eslint-disable-next-line no-unused-vars
function shouldParseDefaultImport() {
    return match(2048 /* name */);
}
function parseImportSpecifierLocal() {
    parseIdentifier();
}
// Parses a comma-separated list of module imports.
function parseImportSpecifiers() {
    if (hasPlugin("flow")) {
        flowStartParseImportSpecifiers();
    }
    let first = true;
    if (shouldParseDefaultImport()) {
        // import defaultObj, { x, y as z } from '...'
        parseImportSpecifierLocal();
        if (!eat(7168 /* comma */))
            return;
    }
    if (match(24587 /* star */)) {
        next();
        expectContextual(2 /* _as */);
        parseImportSpecifierLocal();
        return;
    }
    expect(4096 /* braceL */);
    while (!eat(5120 /* braceR */)) {
        if (first) {
            first = false;
        }
        else {
            // Detect an attempt to deep destructure
            if (eat(8192 /* colon */)) {
                unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
            }
            expect(7168 /* comma */);
            if (eat(5120 /* braceR */))
                break;
        }
        parseImportSpecifier();
    }
}
function parseImportSpecifier() {
    if (hasPlugin("flow")) {
        flowParseImportSpecifier();
        return;
    }
    parseIdentifier();
    if (eatContextual(2 /* _as */)) {
        parseIdentifier();
    }
}
