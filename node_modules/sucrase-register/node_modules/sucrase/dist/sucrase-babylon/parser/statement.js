"use strict";
/* eslint max-len: 0 */
Object.defineProperty(exports, "__esModule", { value: true });
const flow_1 = require("../plugins/flow");
const typescript_1 = require("../plugins/typescript");
const tokenizer_1 = require("../tokenizer");
const base_1 = require("./base");
const expression_1 = require("./expression");
const lval_1 = require("./lval");
const util_1 = require("./util");
function parseTopLevel() {
    parseBlockBody(true, 2560 /* eof */);
    base_1.state.scopes.push({
        startTokenIndex: 0,
        endTokenIndex: base_1.state.tokens.length,
        isFunctionScope: true,
    });
    return {
        tokens: base_1.state.tokens,
        scopes: base_1.state.scopes,
    };
}
exports.parseTopLevel = parseTopLevel;
// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.
function parseStatement(declaration, topLevel = false) {
    if (base_1.hasPlugin("flow")) {
        if (flow_1.flowTryParseStatement()) {
            return;
        }
    }
    if (tokenizer_1.match(13312 /* at */)) {
        parseDecorators();
    }
    parseStatementContent(declaration, topLevel);
}
exports.parseStatement = parseStatement;
function parseStatementContent(declaration, topLevel) {
    if (base_1.hasPlugin("typescript")) {
        if (typescript_1.tsTryParseStatementContent()) {
            return;
        }
    }
    const starttype = base_1.state.type;
    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.
    switch (starttype) {
        case 29200 /* _break */:
        case 30736 /* _continue */:
            parseBreakContinueStatement();
            return;
        case 31248 /* _debugger */:
            parseDebuggerStatement();
            return;
        case 32272 /* _do */:
            parseDoStatement();
            return;
        case 33808 /* _for */:
            parseForStatement();
            return;
        case 34320 /* _function */:
            if (tokenizer_1.lookaheadType() === 9216 /* dot */)
                break;
            if (!declaration)
                util_1.unexpected();
            parseFunctionStatement();
            return;
        case 41488 /* _class */:
            if (!declaration)
                util_1.unexpected();
            parseClass(true);
            return;
        case 34832 /* _if */:
            parseIfStatement();
            return;
        case 35344 /* _return */:
            parseReturnStatement();
            return;
        case 35856 /* _switch */:
            parseSwitchStatement();
            return;
        case 36496 /* _throw */:
            parseThrowStatement();
            return;
        case 36880 /* _try */:
            parseTryStatement();
            return;
        case 37904 /* _let */:
        case 38416 /* _const */:
            if (!declaration)
                util_1.unexpected(); // NOTE: falls through to _var
        case 37392 /* _var */:
            parseVarStatement(starttype);
            return;
        case 38928 /* _while */:
            parseWhileStatement();
            return;
        case 4096 /* braceL */:
            parseBlock();
            return;
        case 7680 /* semi */:
            parseEmptyStatement();
            return;
        case 42512 /* _export */:
        case 43024 /* _import */: {
            const nextType = tokenizer_1.lookaheadType();
            if (nextType === 6144 /* parenL */ || nextType === 9216 /* dot */) {
                break;
            }
            tokenizer_1.next();
            if (starttype === 43024 /* _import */) {
                parseImport();
            }
            else {
                parseExport();
            }
            return;
        }
        case 2048 /* name */:
            if (base_1.state.contextualKeyword === 3 /* _async */) {
                const functionStart = base_1.state.start;
                // peek ahead and see if next token is a function
                const snapshot = base_1.state.snapshot();
                tokenizer_1.next();
                if (tokenizer_1.match(34320 /* _function */) && !util_1.canInsertSemicolon()) {
                    util_1.expect(34320 /* _function */);
                    parseFunction(functionStart, true, false);
                    return;
                }
                else {
                    base_1.state.restoreFromSnapshot(snapshot);
                }
            }
        default:
            // Do nothing.
            break;
    }
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    const initialTokensLength = base_1.state.tokens.length;
    expression_1.parseExpression();
    let simpleName = null;
    if (base_1.state.tokens.length === initialTokensLength + 1) {
        const token = base_1.state.tokens[base_1.state.tokens.length - 1];
        if (token.type === 2048 /* name */) {
            simpleName = token.contextualKeyword;
        }
    }
    if (simpleName == null) {
        util_1.semicolon();
        return;
    }
    if (tokenizer_1.eat(8192 /* colon */)) {
        parseLabeledStatement();
    }
    else {
        // This was an identifier, so we might want to handle flow/typescript-specific cases.
        parseIdentifierStatement(simpleName);
    }
}
function parseDecorators() {
    while (tokenizer_1.match(13312 /* at */)) {
        parseDecorator();
    }
}
exports.parseDecorators = parseDecorators;
function parseDecorator() {
    tokenizer_1.next();
    if (tokenizer_1.eat(6144 /* parenL */)) {
        expression_1.parseExpression();
        util_1.expect(6656 /* parenR */);
    }
    else {
        expression_1.parseIdentifier();
        while (tokenizer_1.eat(9216 /* dot */)) {
            expression_1.parseIdentifier();
        }
    }
    if (tokenizer_1.eat(6144 /* parenL */)) {
        expression_1.parseCallExpressionArguments(6656 /* parenR */);
    }
}
function parseBreakContinueStatement() {
    tokenizer_1.next();
    if (!util_1.isLineTerminator()) {
        expression_1.parseIdentifier();
        util_1.semicolon();
    }
}
function parseDebuggerStatement() {
    tokenizer_1.next();
    util_1.semicolon();
}
function parseDoStatement() {
    tokenizer_1.next();
    parseStatement(false);
    util_1.expect(38928 /* _while */);
    expression_1.parseParenExpression();
    tokenizer_1.eat(7680 /* semi */);
}
function parseForStatement() {
    const startTokenIndex = base_1.state.tokens.length;
    parseAmbiguousForStatement();
    const endTokenIndex = base_1.state.tokens.length;
    base_1.state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: false });
}
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
function parseAmbiguousForStatement() {
    tokenizer_1.next();
    let forAwait = false;
    if (util_1.isContextual(4 /* _await */)) {
        forAwait = true;
        tokenizer_1.next();
    }
    util_1.expect(6144 /* parenL */);
    if (tokenizer_1.match(7680 /* semi */)) {
        if (forAwait) {
            util_1.unexpected();
        }
        parseFor();
        return;
    }
    if (tokenizer_1.match(37392 /* _var */) || tokenizer_1.match(37904 /* _let */) || tokenizer_1.match(38416 /* _const */)) {
        const varKind = base_1.state.type;
        tokenizer_1.next();
        parseVar(true, varKind);
        if (tokenizer_1.match(45592 /* _in */) || util_1.isContextual(21 /* _of */)) {
            parseForIn(forAwait);
            return;
        }
        parseFor();
        return;
    }
    expression_1.parseExpression(true);
    if (tokenizer_1.match(45592 /* _in */) || util_1.isContextual(21 /* _of */)) {
        parseForIn(forAwait);
        return;
    }
    if (forAwait) {
        util_1.unexpected();
    }
    parseFor();
}
function parseFunctionStatement() {
    const functionStart = base_1.state.start;
    tokenizer_1.next();
    parseFunction(functionStart, true);
}
function parseIfStatement() {
    tokenizer_1.next();
    expression_1.parseParenExpression();
    parseStatement(false);
    if (tokenizer_1.eat(32784 /* _else */)) {
        parseStatement(false);
    }
}
function parseReturnStatement() {
    tokenizer_1.next();
    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.
    if (!util_1.isLineTerminator()) {
        expression_1.parseExpression();
        util_1.semicolon();
    }
}
function parseSwitchStatement() {
    tokenizer_1.next();
    expression_1.parseParenExpression();
    const startTokenIndex = base_1.state.tokens.length;
    util_1.expect(4096 /* braceL */);
    // Don't bother validation; just go through any sequence of cases, defaults, and statements.
    while (!tokenizer_1.match(5120 /* braceR */)) {
        if (tokenizer_1.match(29712 /* _case */) || tokenizer_1.match(31760 /* _default */)) {
            const isCase = tokenizer_1.match(29712 /* _case */);
            tokenizer_1.next();
            if (isCase) {
                expression_1.parseExpression();
            }
            util_1.expect(8192 /* colon */);
        }
        else {
            parseStatement(true);
        }
    }
    tokenizer_1.next(); // Closing brace
    const endTokenIndex = base_1.state.tokens.length;
    base_1.state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: false });
}
function parseThrowStatement() {
    tokenizer_1.next();
    expression_1.parseExpression();
    util_1.semicolon();
}
function parseTryStatement() {
    tokenizer_1.next();
    parseBlock();
    if (tokenizer_1.match(30224 /* _catch */)) {
        tokenizer_1.next();
        let catchBindingStartTokenIndex = null;
        if (tokenizer_1.match(6144 /* parenL */)) {
            catchBindingStartTokenIndex = base_1.state.tokens.length;
            util_1.expect(6144 /* parenL */);
            lval_1.parseBindingAtom(true /* isBlockScope */);
            util_1.expect(6656 /* parenR */);
        }
        parseBlock();
        if (catchBindingStartTokenIndex != null) {
            // We need a special scope for the catch binding which includes the binding itself and the
            // catch block.
            const endTokenIndex = base_1.state.tokens.length;
            base_1.state.scopes.push({
                startTokenIndex: catchBindingStartTokenIndex,
                endTokenIndex,
                isFunctionScope: false,
            });
        }
    }
    if (tokenizer_1.eat(33296 /* _finally */)) {
        parseBlock();
    }
}
function parseVarStatement(kind) {
    tokenizer_1.next();
    parseVar(false, kind);
    util_1.semicolon();
}
exports.parseVarStatement = parseVarStatement;
function parseWhileStatement() {
    tokenizer_1.next();
    expression_1.parseParenExpression();
    parseStatement(false);
}
function parseEmptyStatement() {
    tokenizer_1.next();
}
function parseLabeledStatement() {
    parseStatement(true);
}
/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */
function parseIdentifierStatement(contextualKeyword) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsParseIdentifierStatement(contextualKeyword);
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowParseIdentifierStatement(contextualKeyword);
    }
    else {
        util_1.semicolon();
    }
}
// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).
function parseBlock(allowDirectives = false, isFunctionScope = false, contextId) {
    const startTokenIndex = base_1.state.tokens.length;
    util_1.expect(4096 /* braceL */);
    if (contextId) {
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = contextId;
    }
    parseBlockBody(false, 5120 /* braceR */);
    if (contextId) {
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = contextId;
    }
    const endTokenIndex = base_1.state.tokens.length;
    base_1.state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope });
}
exports.parseBlock = parseBlock;
function parseBlockBody(topLevel, end) {
    while (!tokenizer_1.eat(end)) {
        parseStatement(true, topLevel);
    }
}
exports.parseBlockBody = parseBlockBody;
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
function parseFor() {
    util_1.expect(7680 /* semi */);
    if (!tokenizer_1.match(7680 /* semi */)) {
        expression_1.parseExpression();
    }
    util_1.expect(7680 /* semi */);
    if (!tokenizer_1.match(6656 /* parenR */)) {
        expression_1.parseExpression();
    }
    util_1.expect(6656 /* parenR */);
    parseStatement(false);
}
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
function parseForIn(forAwait) {
    if (forAwait) {
        util_1.eatContextual(21 /* _of */);
    }
    else {
        tokenizer_1.next();
    }
    expression_1.parseExpression();
    util_1.expect(6656 /* parenR */);
    parseStatement(false);
}
// Parse a list of variable declarations.
function parseVar(isFor, kind) {
    while (true) {
        const isBlockScope = kind === 38416 /* _const */ || kind === 37904 /* _let */;
        parseVarHead(isBlockScope);
        if (tokenizer_1.eat(14368 /* eq */)) {
            expression_1.parseMaybeAssign(isFor);
        }
        if (!tokenizer_1.eat(7168 /* comma */))
            break;
    }
}
function parseVarHead(isBlockScope) {
    lval_1.parseBindingAtom(isBlockScope);
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsAfterParseVarHead();
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowAfterParseVarHead();
    }
}
// Parse a function declaration or literal (depending on the
// `isStatement` parameter).
function parseFunction(functionStart, isStatement, allowExpressionBody, optionalId) {
    let isGenerator = false;
    if (tokenizer_1.match(24587 /* star */)) {
        isGenerator = true;
        tokenizer_1.next();
    }
    if (isStatement && !optionalId && !tokenizer_1.match(2048 /* name */) && !tokenizer_1.match(43536 /* _yield */)) {
        util_1.unexpected();
    }
    let nameScopeStartTokenIndex = null;
    if (tokenizer_1.match(2048 /* name */)) {
        // Expression-style functions should limit their name's scope to the function body, so we make
        // a new function scope to enforce that.
        if (!isStatement) {
            nameScopeStartTokenIndex = base_1.state.tokens.length;
        }
        lval_1.parseBindingIdentifier();
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.FunctionScopedDeclaration;
    }
    const startTokenIndex = base_1.state.tokens.length;
    parseFunctionParams();
    expression_1.parseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody);
    const endTokenIndex = base_1.state.tokens.length;
    // In addition to the block scope of the function body, we need a separate function-style scope
    // that includes the params.
    base_1.state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: true });
    if (nameScopeStartTokenIndex !== null) {
        base_1.state.scopes.push({
            startTokenIndex: nameScopeStartTokenIndex,
            endTokenIndex,
            isFunctionScope: true,
        });
    }
}
exports.parseFunction = parseFunction;
function parseFunctionParams(allowModifiers, funcContextId) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsStartParseFunctionParams();
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowStartParseFunctionParams();
    }
    util_1.expect(6144 /* parenL */);
    if (funcContextId) {
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = funcContextId;
    }
    lval_1.parseBindingList(6656 /* parenR */, false /* isBlockScope */, false /* allowEmpty */, allowModifiers);
    if (funcContextId) {
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = funcContextId;
    }
}
exports.parseFunctionParams = parseFunctionParams;
// Parse a class declaration or literal (depending on the
// `isStatement` parameter).
function parseClass(isStatement, optionalId = false) {
    // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
    // code can easily navigate to meaningful points on the class.
    const contextId = base_1.getNextContextId();
    tokenizer_1.next();
    base_1.state.tokens[base_1.state.tokens.length - 1].contextId = contextId;
    base_1.state.tokens[base_1.state.tokens.length - 1].isExpression = !isStatement;
    // Like with functions, we declare a special "name scope" from the start of the name to the end
    // of the class, but only with expression-style classes, to represent the fact that the name is
    // available to the body of the class but not an outer declaration.
    let nameScopeStartTokenIndex = null;
    if (!isStatement) {
        nameScopeStartTokenIndex = base_1.state.tokens.length;
    }
    parseClassId(isStatement, optionalId);
    parseClassSuper();
    const openBraceIndex = base_1.state.tokens.length;
    parseClassBody(contextId);
    base_1.state.tokens[openBraceIndex].contextId = contextId;
    base_1.state.tokens[base_1.state.tokens.length - 1].contextId = contextId;
    if (nameScopeStartTokenIndex !== null) {
        const endTokenIndex = base_1.state.tokens.length;
        base_1.state.scopes.push({
            startTokenIndex: nameScopeStartTokenIndex,
            endTokenIndex,
            isFunctionScope: false,
        });
    }
}
exports.parseClass = parseClass;
function isClassProperty() {
    return tokenizer_1.match(14368 /* eq */) || tokenizer_1.match(7680 /* semi */) || tokenizer_1.match(5120 /* braceR */) || tokenizer_1.match(16000 /* bang */) || tokenizer_1.match(8192 /* colon */);
}
function isClassMethod() {
    return tokenizer_1.match(6144 /* parenL */) || tokenizer_1.match(21000 /* lessThan */);
}
function parseClassBody(classContextId) {
    util_1.expect(4096 /* braceL */);
    while (!tokenizer_1.eat(5120 /* braceR */)) {
        if (tokenizer_1.eat(7680 /* semi */)) {
            continue;
        }
        if (tokenizer_1.match(13312 /* at */)) {
            parseDecorator();
            continue;
        }
        const memberStart = base_1.state.start;
        parseClassMember(memberStart, classContextId);
    }
}
function parseClassMember(memberStart, classContextId) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsParseAccessModifier();
    }
    let isStatic = false;
    if (tokenizer_1.match(2048 /* name */) && base_1.state.contextualKeyword === 29 /* _static */) {
        expression_1.parseIdentifier(); // eats 'static'
        if (isClassMethod()) {
            parseClassMethod(memberStart, false, /* isConstructor */ false);
            return;
        }
        else if (isClassProperty()) {
            parseClassProperty();
            return;
        }
        // otherwise something static
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 51216 /* _static */;
        isStatic = true;
    }
    parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}
function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
    if (base_1.hasPlugin("typescript")) {
        if (typescript_1.tsTryParseClassMemberWithIsStatic(isStatic, classContextId)) {
            return;
        }
    }
    if (tokenizer_1.eat(24587 /* star */)) {
        // a generator
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, true, /* isConstructor */ false);
        return;
    }
    // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
    // "set".
    parseClassPropertyName(classContextId);
    let isConstructor = false;
    const token = base_1.state.tokens[base_1.state.tokens.length - 1];
    // We allow "constructor" as either an identifier or a string.
    if (token.contextualKeyword === 6 /* _constructor */) {
        isConstructor = true;
    }
    parsePostMemberNameModifiers();
    if (isClassMethod()) {
        parseClassMethod(memberStart, false, isConstructor);
    }
    else if (isClassProperty()) {
        parseClassProperty();
    }
    else if (token.contextualKeyword === 3 /* _async */ && !util_1.isLineTerminator()) {
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 48144 /* _async */;
        // an async method
        const isGenerator = tokenizer_1.match(24587 /* star */);
        if (isGenerator) {
            tokenizer_1.next();
        }
        // The so-called parsed name would have been "async": get the real name.
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, isGenerator, false /* isConstructor */);
    }
    else if ((token.contextualKeyword === 11 /* _get */ ||
        token.contextualKeyword === 28 /* _set */) &&
        !(util_1.isLineTerminator() && tokenizer_1.match(24587 /* star */))) {
        if (token.contextualKeyword === 11 /* _get */) {
            base_1.state.tokens[base_1.state.tokens.length - 1].type = 48656 /* _get */;
        }
        else {
            base_1.state.tokens[base_1.state.tokens.length - 1].type = 49168 /* _set */;
        }
        // `get\n*` is an uninitialized property named 'get' followed by a generator.
        // a getter or setter
        // The so-called parsed name would have been "get/set": get the real name.
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, false, /* isConstructor */ false);
    }
    else if (util_1.isLineTerminator()) {
        // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
        parseClassProperty();
    }
    else {
        util_1.unexpected();
    }
}
function parseClassMethod(functionStart, isGenerator, isConstructor) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsTryParseTypeParameters();
    }
    else if (base_1.hasPlugin("flow")) {
        if (tokenizer_1.match(21000 /* lessThan */)) {
            flow_1.flowParseTypeParameterDeclaration();
        }
    }
    expression_1.parseMethod(functionStart, isGenerator, isConstructor);
}
// Return the name of the class property, if it is a simple identifier.
function parseClassPropertyName(classContextId) {
    expression_1.parsePropertyName(classContextId);
}
exports.parseClassPropertyName = parseClassPropertyName;
function parsePostMemberNameModifiers() {
    if (base_1.hasPlugin("typescript")) {
        tokenizer_1.eat(9728 /* question */);
    }
}
exports.parsePostMemberNameModifiers = parsePostMemberNameModifiers;
function parseClassProperty() {
    if (base_1.hasPlugin("typescript")) {
        tokenizer_1.eat(16000 /* bang */);
        typescript_1.tsTryParseTypeAnnotation();
    }
    else if (base_1.hasPlugin("flow")) {
        if (tokenizer_1.match(8192 /* colon */)) {
            flow_1.flowParseTypeAnnotation();
        }
    }
    if (tokenizer_1.match(14368 /* eq */)) {
        const equalsTokenIndex = base_1.state.tokens.length;
        tokenizer_1.next();
        expression_1.parseMaybeAssign();
        base_1.state.tokens[equalsTokenIndex].rhsEndIndex = base_1.state.tokens.length;
    }
    util_1.semicolon();
}
exports.parseClassProperty = parseClassProperty;
function parseClassId(isStatement, optionalId = false) {
    if (base_1.hasPlugin("typescript") &&
        (!isStatement || optionalId) &&
        util_1.isContextual(13 /* _implements */)) {
        return;
    }
    if (tokenizer_1.match(2048 /* name */)) {
        expression_1.parseIdentifier();
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.BlockScopedDeclaration;
    }
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsTryParseTypeParameters();
    }
    else if (base_1.hasPlugin("flow")) {
        if (tokenizer_1.match(21000 /* lessThan */)) {
            flow_1.flowParseTypeParameterDeclaration();
        }
    }
}
// Returns true if there was a superclass.
function parseClassSuper() {
    let hasSuper;
    if (tokenizer_1.eat(42000 /* _extends */)) {
        expression_1.parseExprSubscripts();
        hasSuper = true;
    }
    else {
        hasSuper = false;
    }
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsAfterParseClassSuper(hasSuper);
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowAfterParseClassSuper(hasSuper);
    }
}
// Parses module export declaration.
function parseExport() {
    if (base_1.hasPlugin("typescript")) {
        if (typescript_1.tsTryParseExport()) {
            return;
        }
    }
    // export * from '...'
    if (shouldParseExportStar()) {
        parseExportStar();
    }
    else if (isExportDefaultSpecifier()) {
        // export default from
        expression_1.parseIdentifier();
        if (tokenizer_1.match(7168 /* comma */) && tokenizer_1.lookaheadType() === 24587 /* star */) {
            util_1.expect(7168 /* comma */);
            util_1.expect(24587 /* star */);
            util_1.expectContextual(2 /* _as */);
            expression_1.parseIdentifier();
        }
        else {
            parseExportSpecifiersMaybe();
        }
        parseExportFrom();
    }
    else if (tokenizer_1.eat(31760 /* _default */)) {
        // export default ...
        parseExportDefaultExpression();
    }
    else if (shouldParseExportDeclaration()) {
        parseExportDeclaration();
    }
    else {
        // export { x, y as z } [from '...']
        parseExportSpecifiers();
        parseExportFrom();
    }
}
exports.parseExport = parseExport;
function parseExportDefaultExpression() {
    if (base_1.hasPlugin("typescript")) {
        if (typescript_1.tsTryParseExportDefaultExpression()) {
            return;
        }
    }
    const functionStart = base_1.state.start;
    if (tokenizer_1.eat(34320 /* _function */)) {
        parseFunction(functionStart, true, false, true);
    }
    else if (util_1.isContextual(3 /* _async */) && tokenizer_1.lookaheadType() === 34320 /* _function */) {
        // async function declaration
        util_1.eatContextual(3 /* _async */);
        tokenizer_1.eat(34320 /* _function */);
        parseFunction(functionStart, true, false, true);
    }
    else if (tokenizer_1.match(41488 /* _class */)) {
        parseClass(true, true);
    }
    else if (tokenizer_1.match(13312 /* at */)) {
        parseDecorators();
        parseClass(true, true);
    }
    else {
        expression_1.parseMaybeAssign();
        util_1.semicolon();
    }
}
function parseExportDeclaration() {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsParseExportDeclaration();
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowParseExportDeclaration();
    }
    else {
        parseStatement(true);
    }
}
function isExportDefaultSpecifier() {
    if (base_1.hasPlugin("typescript") && typescript_1.tsIsDeclarationStart()) {
        return false;
    }
    else if (base_1.hasPlugin("flow") && flow_1.flowShouldDisallowExportDefaultSpecifier()) {
        return false;
    }
    if (tokenizer_1.match(2048 /* name */)) {
        return base_1.state.contextualKeyword !== 3 /* _async */;
    }
    if (!tokenizer_1.match(31760 /* _default */)) {
        return false;
    }
    const lookahead = tokenizer_1.lookaheadTypeAndKeyword();
    return (lookahead.type === 7168 /* comma */ ||
        (lookahead.type === 2048 /* name */ && lookahead.contextualKeyword === 10 /* _from */));
}
function parseExportSpecifiersMaybe() {
    if (tokenizer_1.eat(7168 /* comma */)) {
        parseExportSpecifiers();
    }
}
function parseExportFrom() {
    if (util_1.eatContextual(10 /* _from */)) {
        expression_1.parseExprAtom();
    }
    util_1.semicolon();
}
exports.parseExportFrom = parseExportFrom;
function shouldParseExportStar() {
    if (base_1.hasPlugin("flow")) {
        return flow_1.flowShouldParseExportStar();
    }
    else {
        return tokenizer_1.match(24587 /* star */);
    }
}
function parseExportStar() {
    if (base_1.hasPlugin("flow")) {
        flow_1.flowParseExportStar();
    }
    else {
        baseParseExportStar();
    }
}
function baseParseExportStar() {
    util_1.expect(24587 /* star */);
    if (util_1.isContextual(2 /* _as */)) {
        parseExportNamespace();
    }
    else {
        parseExportFrom();
    }
}
exports.baseParseExportStar = baseParseExportStar;
function parseExportNamespace() {
    tokenizer_1.next();
    base_1.state.tokens[base_1.state.tokens.length - 1].type = 53264 /* _as */;
    expression_1.parseIdentifier();
    parseExportSpecifiersMaybe();
    parseExportFrom();
}
function shouldParseExportDeclaration() {
    return ((base_1.hasPlugin("typescript") && typescript_1.tsIsDeclarationStart()) ||
        (base_1.hasPlugin("flow") && flow_1.flowShouldParseExportDeclaration()) ||
        base_1.state.type === 37392 /* _var */ ||
        base_1.state.type === 38416 /* _const */ ||
        base_1.state.type === 37904 /* _let */ ||
        base_1.state.type === 34320 /* _function */ ||
        base_1.state.type === 41488 /* _class */ ||
        util_1.isContextual(3 /* _async */) ||
        tokenizer_1.match(13312 /* at */));
}
// Parses a comma-separated list of module exports.
function parseExportSpecifiers() {
    let first = true;
    // export { x, y as z } [from '...']
    util_1.expect(4096 /* braceL */);
    while (!tokenizer_1.eat(5120 /* braceR */)) {
        if (first) {
            first = false;
        }
        else {
            util_1.expect(7168 /* comma */);
            if (tokenizer_1.eat(5120 /* braceR */))
                break;
        }
        expression_1.parseIdentifier();
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.ExportAccess;
        if (util_1.eatContextual(2 /* _as */)) {
            expression_1.parseIdentifier();
        }
    }
}
exports.parseExportSpecifiers = parseExportSpecifiers;
// Parses import declaration.
function parseImport() {
    if (base_1.hasPlugin("typescript") && tokenizer_1.match(2048 /* name */) && tokenizer_1.lookaheadType() === 14368 /* eq */) {
        typescript_1.tsParseImportEqualsDeclaration();
        return;
    }
    // import '...'
    if (tokenizer_1.match(1536 /* string */)) {
        expression_1.parseExprAtom();
    }
    else {
        parseImportSpecifiers();
        util_1.expectContextual(10 /* _from */);
        expression_1.parseExprAtom();
    }
    util_1.semicolon();
}
exports.parseImport = parseImport;
// eslint-disable-next-line no-unused-vars
function shouldParseDefaultImport() {
    return tokenizer_1.match(2048 /* name */);
}
function parseImportSpecifierLocal() {
    expression_1.parseIdentifier();
}
// Parses a comma-separated list of module imports.
function parseImportSpecifiers() {
    if (base_1.hasPlugin("flow")) {
        flow_1.flowStartParseImportSpecifiers();
    }
    let first = true;
    if (shouldParseDefaultImport()) {
        // import defaultObj, { x, y as z } from '...'
        parseImportSpecifierLocal();
        if (!tokenizer_1.eat(7168 /* comma */))
            return;
    }
    if (tokenizer_1.match(24587 /* star */)) {
        tokenizer_1.next();
        util_1.expectContextual(2 /* _as */);
        parseImportSpecifierLocal();
        return;
    }
    util_1.expect(4096 /* braceL */);
    while (!tokenizer_1.eat(5120 /* braceR */)) {
        if (first) {
            first = false;
        }
        else {
            // Detect an attempt to deep destructure
            if (tokenizer_1.eat(8192 /* colon */)) {
                util_1.unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
            }
            util_1.expect(7168 /* comma */);
            if (tokenizer_1.eat(5120 /* braceR */))
                break;
        }
        parseImportSpecifier();
    }
}
function parseImportSpecifier() {
    if (base_1.hasPlugin("flow")) {
        flow_1.flowParseImportSpecifier();
        return;
    }
    expression_1.parseIdentifier();
    if (util_1.eatContextual(2 /* _as */)) {
        expression_1.parseIdentifier();
    }
}
