"use strict";
/* eslint max-len: 0 */
Object.defineProperty(exports, "__esModule", { value: true });
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts â€” that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
const flow_1 = require("../plugins/flow");
const jsx_1 = require("../plugins/jsx");
const types_1 = require("../plugins/types");
const typescript_1 = require("../plugins/typescript");
const tokenizer_1 = require("../tokenizer");
const base_1 = require("./base");
const lval_1 = require("./lval");
const statement_1 = require("./statement");
const util_1 = require("./util");
// ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initialization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).e
function parseExpression(noIn) {
    parseMaybeAssign(noIn);
    if (tokenizer_1.match(7168 /* comma */)) {
        while (tokenizer_1.eat(7168 /* comma */)) {
            parseMaybeAssign(noIn);
        }
    }
}
exports.parseExpression = parseExpression;
function parseMaybeAssign(noIn = null, afterLeftParse) {
    if (base_1.hasPlugin("typescript")) {
        return typescript_1.tsParseMaybeAssign(noIn, afterLeftParse);
    }
    else if (base_1.hasPlugin("flow")) {
        return flow_1.flowParseMaybeAssign(noIn, afterLeftParse);
    }
    else {
        return baseParseMaybeAssign(noIn, afterLeftParse);
    }
}
exports.parseMaybeAssign = parseMaybeAssign;
// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
function baseParseMaybeAssign(noIn = null, afterLeftParse) {
    if (tokenizer_1.match(43536 /* _yield */)) {
        parseYield();
        if (afterLeftParse) {
            afterLeftParse();
        }
        return false;
    }
    if (tokenizer_1.match(6144 /* parenL */) || tokenizer_1.match(2048 /* name */) || tokenizer_1.match(43536 /* _yield */)) {
        base_1.state.potentialArrowAt = base_1.state.start;
    }
    const wasArrow = parseMaybeConditional(noIn);
    if (afterLeftParse) {
        afterLeftParse();
    }
    if (base_1.state.type & 32 /* IS_ASSIGN */) {
        tokenizer_1.next();
        parseMaybeAssign(noIn);
        return false;
    }
    return wasArrow;
}
exports.baseParseMaybeAssign = baseParseMaybeAssign;
// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
    const startPos = base_1.state.start;
    const wasArrow = parseExprOps(noIn);
    if (wasArrow) {
        return true;
    }
    parseConditional(noIn, startPos);
    return false;
}
function parseConditional(noIn, startPos) {
    if (base_1.hasPlugin("typescript") || base_1.hasPlugin("flow")) {
        types_1.typedParseConditional(noIn, startPos);
    }
    else {
        baseParseConditional(noIn, startPos);
    }
}
function baseParseConditional(noIn, startPos) {
    if (tokenizer_1.eat(9728 /* question */)) {
        parseMaybeAssign();
        util_1.expect(8192 /* colon */);
        parseMaybeAssign(noIn);
    }
}
exports.baseParseConditional = baseParseConditional;
// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
    const wasArrow = parseMaybeUnary();
    if (wasArrow) {
        return true;
    }
    parseExprOp(-1, noIn);
    return false;
}
// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(minPrec, noIn) {
    if (base_1.hasPlugin("typescript") &&
        (45592 /* _in */ & 15 /* PRECEDENCE_MASK */) > minPrec &&
        !util_1.hasPrecedingLineBreak() &&
        util_1.eatContextual(2 /* _as */)) {
        base_1.state.tokens[base_1.state.tokens.length - 1].type = 53264 /* _as */;
        tokenizer_1.runInTypeContext(1, () => {
            typescript_1.tsParseType();
        });
        parseExprOp(minPrec, noIn);
        return;
    }
    const prec = base_1.state.type & 15 /* PRECEDENCE_MASK */;
    if (prec > 0 && (!noIn || !tokenizer_1.match(45592 /* _in */))) {
        if (prec > minPrec) {
            const op = base_1.state.type;
            tokenizer_1.next();
            if (op === 16897 /* pipeline */) {
                // Support syntax such as 10 |> x => x + 1
                base_1.state.potentialArrowAt = base_1.state.start;
            }
            parseMaybeUnary();
            parseExprOp(op & 64 /* IS_RIGHT_ASSOCIATIVE */ ? prec - 1 : prec, noIn);
            parseExprOp(minPrec, noIn);
        }
    }
}
// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
function parseMaybeUnary() {
    if (base_1.hasPlugin("typescript") && !base_1.hasPlugin("jsx") && tokenizer_1.eat(21000 /* lessThan */)) {
        typescript_1.tsParseTypeAssertion();
        return false;
    }
    if (base_1.state.type & 128 /* IS_PREFIX */) {
        tokenizer_1.next();
        parseMaybeUnary();
        return false;
    }
    const wasArrow = parseExprSubscripts();
    if (wasArrow) {
        return true;
    }
    while (base_1.state.type & 256 /* IS_POSTFIX */ && !util_1.canInsertSemicolon()) {
        tokenizer_1.next();
    }
    return false;
}
exports.parseMaybeUnary = parseMaybeUnary;
// Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.
function parseExprSubscripts() {
    const startPos = base_1.state.start;
    const wasArrow = parseExprAtom();
    if (wasArrow) {
        return true;
    }
    parseSubscripts(startPos);
    return false;
}
exports.parseExprSubscripts = parseExprSubscripts;
function parseSubscripts(startPos, noCalls = null) {
    if (base_1.hasPlugin("flow")) {
        flow_1.flowParseSubscripts(startPos, noCalls);
    }
    else {
        baseParseSubscripts(startPos, noCalls);
    }
}
function baseParseSubscripts(startPos, noCalls = null) {
    const stopState = { stop: false };
    do {
        parseSubscript(startPos, noCalls, stopState);
    } while (!stopState.stop);
}
exports.baseParseSubscripts = baseParseSubscripts;
function parseSubscript(startPos, noCalls, stopState) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsParseSubscript(startPos, noCalls, stopState);
    }
    else {
        baseParseSubscript(startPos, noCalls, stopState);
    }
}
/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
function baseParseSubscript(startPos, noCalls, stopState) {
    if (!noCalls && tokenizer_1.eat(8704 /* doubleColon */)) {
        parseNoCallExpr();
        stopState.stop = true;
        parseSubscripts(startPos, noCalls);
    }
    else if (tokenizer_1.match(10240 /* questionDot */)) {
        if (noCalls && tokenizer_1.lookaheadType() === 6144 /* parenL */) {
            stopState.stop = true;
            return;
        }
        tokenizer_1.next();
        if (tokenizer_1.eat(3072 /* bracketL */)) {
            parseExpression();
            util_1.expect(3584 /* bracketR */);
        }
        else if (tokenizer_1.eat(6144 /* parenL */)) {
            parseCallExpressionArguments(6656 /* parenR */);
        }
        else {
            parseIdentifier();
        }
    }
    else if (tokenizer_1.eat(9216 /* dot */)) {
        parseMaybePrivateName();
    }
    else if (tokenizer_1.eat(3072 /* bracketL */)) {
        parseExpression();
        util_1.expect(3584 /* bracketR */);
    }
    else if (!noCalls && tokenizer_1.match(6144 /* parenL */)) {
        const possibleAsync = atPossibleAsync();
        // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
        // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
        const snapshotForAsyncArrow = possibleAsync ? base_1.state.snapshot() : null;
        const startTokenIndex = base_1.state.tokens.length;
        tokenizer_1.next();
        const callContextId = base_1.getNextContextId();
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = callContextId;
        parseCallExpressionArguments(6656 /* parenR */);
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = callContextId;
        if (possibleAsync && shouldParseAsyncArrow()) {
            // We hit an arrow, so backtrack and start again parsing function parameters.
            base_1.state.restoreFromSnapshot(snapshotForAsyncArrow);
            stopState.stop = true;
            statement_1.parseFunctionParams();
            parseAsyncArrowFromCallExpression(startPos, startTokenIndex);
        }
    }
    else if (tokenizer_1.match(12288 /* backQuote */)) {
        // Tagged template expression.
        parseTemplate();
    }
    else {
        stopState.stop = true;
    }
}
exports.baseParseSubscript = baseParseSubscript;
function atPossibleAsync() {
    // This was made less strict than the original version to avoid passing around nodes, but it
    // should be safe to have rare false positives here.
    return (base_1.state.tokens[base_1.state.tokens.length - 1].contextualKeyword === 3 /* _async */ &&
        !util_1.canInsertSemicolon());
}
exports.atPossibleAsync = atPossibleAsync;
function parseCallExpressionArguments(close) {
    let first = true;
    while (!tokenizer_1.eat(close)) {
        if (first) {
            first = false;
        }
        else {
            util_1.expect(7168 /* comma */);
            if (tokenizer_1.eat(close))
                break;
        }
        parseExprListItem(false);
    }
}
exports.parseCallExpressionArguments = parseCallExpressionArguments;
function shouldParseAsyncArrow() {
    return tokenizer_1.match(8192 /* colon */) || tokenizer_1.match(10752 /* arrow */);
}
function parseAsyncArrowFromCallExpression(functionStart, startTokenIndex) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsStartParseAsyncArrowFromCallExpression();
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowStartParseAsyncArrowFromCallExpression();
    }
    util_1.expect(10752 /* arrow */);
    parseArrowExpression(functionStart, startTokenIndex);
}
// Parse a no-call expression (like argument of `new` or `::` operators).
function parseNoCallExpr() {
    const startPos = base_1.state.start;
    parseExprAtom();
    parseSubscripts(startPos, true);
}
// Parse an atomic expression â€” either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
// Returns true if the parsed expression was an arrow function.
function parseExprAtom() {
    if (tokenizer_1.match(26624 /* jsxText */)) {
        parseLiteral();
        return false;
    }
    else if (tokenizer_1.match(21000 /* lessThan */) && base_1.hasPlugin("jsx")) {
        base_1.state.type = 27136 /* jsxTagStart */;
        jsx_1.jsxParseElement();
        tokenizer_1.next();
        return false;
    }
    const canBeArrow = base_1.state.potentialArrowAt === base_1.state.start;
    switch (base_1.state.type) {
        case 25099 /* slash */:
        case 14880 /* assign */:
            tokenizer_1.retokenizeSlashAsRegex();
        // Fall through.
        case 40976 /* _super */:
        case 40464 /* _this */:
        case 1024 /* regexp */:
        case 0 /* num */:
        case 512 /* bigint */:
        case 1536 /* string */:
        case 44048 /* _null */:
        case 44560 /* _true */:
        case 45072 /* _false */:
            tokenizer_1.next();
            return false;
        case 43024 /* _import */:
            if (tokenizer_1.lookaheadType() === 9216 /* dot */) {
                parseImportMetaProperty();
                return false;
            }
            tokenizer_1.next();
            return false;
        case 2048 /* name */: {
            const startTokenIndex = base_1.state.tokens.length;
            const functionStart = base_1.state.start;
            const contextualKeyword = base_1.state.contextualKeyword;
            parseIdentifier();
            if (contextualKeyword === 4 /* _await */) {
                parseAwait();
                return false;
            }
            else if (contextualKeyword === 3 /* _async */ &&
                tokenizer_1.match(34320 /* _function */) &&
                !util_1.canInsertSemicolon()) {
                tokenizer_1.next();
                statement_1.parseFunction(functionStart, false, false);
                return false;
            }
            else if (canBeArrow && contextualKeyword === 3 /* _async */ && tokenizer_1.match(2048 /* name */)) {
                parseIdentifier();
                util_1.expect(10752 /* arrow */);
                // let foo = bar => {};
                parseArrowExpression(functionStart, startTokenIndex);
                return true;
            }
            if (canBeArrow && !util_1.canInsertSemicolon() && tokenizer_1.eat(10752 /* arrow */)) {
                parseArrowExpression(functionStart, startTokenIndex);
                return true;
            }
            base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.Access;
            return false;
        }
        case 32272 /* _do */: {
            tokenizer_1.next();
            statement_1.parseBlock(false);
            return false;
        }
        case 6144 /* parenL */: {
            const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
            return wasArrow;
        }
        case 3072 /* bracketL */:
            tokenizer_1.next();
            parseExprList(3584 /* bracketR */, true);
            return false;
        case 4096 /* braceL */:
            parseObj(false, false);
            return false;
        case 34320 /* _function */:
            parseFunctionExpression();
            return false;
        case 13312 /* at */:
            statement_1.parseDecorators();
        // Fall through.
        case 41488 /* _class */:
            statement_1.parseClass(false);
            return false;
        case 39952 /* _new */:
            parseNew();
            return false;
        case 12288 /* backQuote */:
            parseTemplate();
            return false;
        case 8704 /* doubleColon */: {
            tokenizer_1.next();
            parseNoCallExpr();
            return false;
        }
        default:
            throw util_1.unexpected();
    }
}
exports.parseExprAtom = parseExprAtom;
function parseMaybePrivateName() {
    tokenizer_1.eat(13824 /* hash */);
    parseIdentifier();
}
function parseFunctionExpression() {
    const functionStart = base_1.state.start;
    parseIdentifier();
    if (tokenizer_1.eat(9216 /* dot */)) {
        // function.sent
        parseMetaProperty();
    }
    statement_1.parseFunction(functionStart, false);
}
function parseMetaProperty() {
    parseIdentifier();
}
function parseImportMetaProperty() {
    parseIdentifier();
    util_1.expect(9216 /* dot */);
    // import.meta
    parseMetaProperty();
}
function parseLiteral() {
    tokenizer_1.next();
}
exports.parseLiteral = parseLiteral;
function parseParenExpression() {
    util_1.expect(6144 /* parenL */);
    parseExpression();
    util_1.expect(6656 /* parenR */);
}
exports.parseParenExpression = parseParenExpression;
// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
    // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
    // start over as a parameter list.
    const snapshot = base_1.state.snapshot();
    const startTokenIndex = base_1.state.tokens.length;
    util_1.expect(6144 /* parenL */);
    const exprList = [];
    let first = true;
    let spreadStart;
    let optionalCommaStart;
    while (!tokenizer_1.match(6656 /* parenR */)) {
        if (first) {
            first = false;
        }
        else {
            util_1.expect(7168 /* comma */);
            if (tokenizer_1.match(6656 /* parenR */)) {
                optionalCommaStart = base_1.state.start;
                break;
            }
        }
        if (tokenizer_1.match(11776 /* ellipsis */)) {
            spreadStart = base_1.state.start;
            lval_1.parseRest(false /* isBlockScope */);
            parseParenItem();
            if (tokenizer_1.match(7168 /* comma */) && tokenizer_1.lookaheadType() === 6656 /* parenR */) {
                base_1.raise(base_1.state.start, "A trailing comma is not permitted after the rest element");
            }
            break;
        }
        else {
            exprList.push(parseMaybeAssign(false, parseParenItem));
        }
    }
    util_1.expect(6656 /* parenR */);
    if (canBeArrow && shouldParseArrow()) {
        const wasArrow = parseArrow();
        if (wasArrow) {
            // It was an arrow function this whole time, so start over and parse it as params so that we
            // get proper token annotations.
            base_1.state.restoreFromSnapshot(snapshot);
            // We don't need to worry about functionStart for arrow functions, so just use something.
            const functionStart = base_1.state.start;
            // Don't specify a context ID because arrow function don't need a context ID.
            statement_1.parseFunctionParams();
            parseArrow();
            parseArrowExpression(functionStart, startTokenIndex);
            return true;
        }
    }
    if (optionalCommaStart)
        util_1.unexpected(optionalCommaStart);
    if (spreadStart)
        util_1.unexpected(spreadStart);
    return false;
}
function shouldParseArrow() {
    return tokenizer_1.match(8192 /* colon */) || !util_1.canInsertSemicolon();
}
// Returns whether there was an arrow token.
function parseArrow() {
    if (base_1.hasPlugin("typescript")) {
        return typescript_1.tsParseArrow();
    }
    else if (base_1.hasPlugin("flow")) {
        return flow_1.flowParseArrow();
    }
    else {
        return tokenizer_1.eat(10752 /* arrow */);
    }
}
exports.parseArrow = parseArrow;
function parseParenItem() {
    if (base_1.hasPlugin("typescript") || base_1.hasPlugin("flow")) {
        types_1.typedParseParenItem();
    }
}
// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call â€” at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
    parseIdentifier();
    if (tokenizer_1.eat(9216 /* dot */)) {
        // new.target
        parseMetaProperty();
        return;
    }
    parseNoCallExpr();
    tokenizer_1.eat(10240 /* questionDot */);
    parseNewArguments();
}
function parseNewArguments() {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsStartParseNewArguments();
    }
    if (tokenizer_1.eat(6144 /* parenL */)) {
        parseExprList(6656 /* parenR */);
    }
}
function parseTemplate() {
    // Finish `, read quasi
    tokenizer_1.nextTemplateToken();
    // Finish quasi, read ${
    tokenizer_1.nextTemplateToken();
    while (!tokenizer_1.match(12288 /* backQuote */)) {
        util_1.expect(12800 /* dollarBraceL */);
        parseExpression();
        // Finish }, read quasi
        tokenizer_1.nextTemplateToken();
        // Finish quasi, read either ${ or `
        tokenizer_1.nextTemplateToken();
    }
    tokenizer_1.next();
}
// Parse an object literal or binding pattern.
function parseObj(isPattern, isBlockScope) {
    // Attach a context ID to the object open and close brace and each object key.
    const contextId = base_1.getNextContextId();
    let first = true;
    tokenizer_1.next();
    base_1.state.tokens[base_1.state.tokens.length - 1].contextId = contextId;
    let firstRestLocation = null;
    while (!tokenizer_1.eat(5120 /* braceR */)) {
        if (first) {
            first = false;
        }
        else {
            util_1.expect(7168 /* comma */);
            if (tokenizer_1.eat(5120 /* braceR */)) {
                break;
            }
        }
        let isGenerator = false;
        if (tokenizer_1.match(11776 /* ellipsis */)) {
            // Note that this is labeled as an access on the token even though it might be an
            // assignment.
            lval_1.parseSpread();
            if (isPattern) {
                const position = base_1.state.start;
                if (firstRestLocation !== null) {
                    util_1.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
                }
                else if (tokenizer_1.eat(5120 /* braceR */)) {
                    break;
                }
                else if (tokenizer_1.match(7168 /* comma */) && tokenizer_1.lookaheadType() === 5120 /* braceR */) {
                    util_1.unexpected(position, "A trailing comma is not permitted after the rest element");
                }
                else {
                    firstRestLocation = position;
                    continue;
                }
            }
            else {
                continue;
            }
        }
        if (!isPattern) {
            isGenerator = tokenizer_1.eat(24587 /* star */);
        }
        if (!isPattern && util_1.isContextual(3 /* _async */)) {
            if (isGenerator)
                util_1.unexpected();
            parseIdentifier();
            if (tokenizer_1.match(8192 /* colon */) ||
                tokenizer_1.match(6144 /* parenL */) ||
                tokenizer_1.match(5120 /* braceR */) ||
                tokenizer_1.match(14368 /* eq */) ||
                tokenizer_1.match(7168 /* comma */)) {
                // This is a key called "async" rather than an async function.
            }
            else {
                if (tokenizer_1.match(24587 /* star */)) {
                    tokenizer_1.next();
                    isGenerator = true;
                }
                parsePropertyName(contextId);
            }
        }
        else {
            parsePropertyName(contextId);
        }
        parseObjPropValue(isGenerator, isPattern, isBlockScope, contextId);
    }
    base_1.state.tokens[base_1.state.tokens.length - 1].contextId = contextId;
}
exports.parseObj = parseObj;
function isGetterOrSetterMethod(isPattern) {
    // We go off of the next and don't bother checking if the node key is actually "get" or "set".
    // This lets us avoid generating a node, and should only make the validation worse.
    return (!isPattern &&
        (tokenizer_1.match(1536 /* string */) || // get "string"() {}
            tokenizer_1.match(0 /* num */) || // get 1() {}
            tokenizer_1.match(3072 /* bracketL */) || // get ["string"]() {}
            tokenizer_1.match(2048 /* name */) || // get foo() {}
            !!(base_1.state.type & 16 /* IS_KEYWORD */)) // get debugger() {}
    );
}
// Returns true if this was a method.
function parseObjectMethod(isGenerator, isPattern, objectContextId) {
    // We don't need to worry about modifiers because object methods can't have optional bodies, so
    // the start will never be used.
    const functionStart = base_1.state.start;
    if (tokenizer_1.match(6144 /* parenL */)) {
        if (isPattern)
            util_1.unexpected();
        parseMethod(functionStart, isGenerator, /* isConstructor */ false);
        return true;
    }
    if (isGetterOrSetterMethod(isPattern)) {
        parsePropertyName(objectContextId);
        parseMethod(functionStart, /* isGenerator */ false, /* isConstructor */ false);
        return true;
    }
    return false;
}
function parseObjectProperty(isPattern, isBlockScope) {
    if (tokenizer_1.eat(8192 /* colon */)) {
        if (isPattern) {
            lval_1.parseMaybeDefault(isBlockScope);
        }
        else {
            parseMaybeAssign(false);
        }
        return;
    }
    // Since there's no colon, we assume this is an object shorthand.
    // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
    // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
    // transform it on access, so mark it as an object shorthand.
    if (isPattern) {
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = isBlockScope
            ? tokenizer_1.IdentifierRole.BlockScopedDeclaration
            : tokenizer_1.IdentifierRole.FunctionScopedDeclaration;
    }
    else {
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.ObjectShorthand;
    }
    // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
    // parsing as if there's a default value.
    lval_1.parseMaybeDefault(isBlockScope, true);
}
function parseObjPropValue(isGenerator, isPattern, isBlockScope, objectContextId) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsStartParseObjPropValue();
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowStartParseObjPropValue();
    }
    const wasMethod = parseObjectMethod(isGenerator, isPattern, objectContextId);
    if (!wasMethod) {
        parseObjectProperty(isPattern, isBlockScope);
    }
}
function parsePropertyName(objectContextId) {
    if (base_1.hasPlugin("flow")) {
        flow_1.flowParseVariance();
    }
    if (tokenizer_1.eat(3072 /* bracketL */)) {
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = objectContextId;
        parseMaybeAssign();
        util_1.expect(3584 /* bracketR */);
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = objectContextId;
    }
    else {
        if (tokenizer_1.match(0 /* num */) || tokenizer_1.match(1536 /* string */)) {
            parseExprAtom();
        }
        else {
            parseMaybePrivateName();
        }
        base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = tokenizer_1.IdentifierRole.ObjectKey;
        base_1.state.tokens[base_1.state.tokens.length - 1].contextId = objectContextId;
    }
}
exports.parsePropertyName = parsePropertyName;
// Parse object or class method.
function parseMethod(functionStart, isGenerator, isConstructor) {
    const funcContextId = base_1.getNextContextId();
    const startTokenIndex = base_1.state.tokens.length;
    const allowModifiers = isConstructor; // For TypeScript parameter properties
    statement_1.parseFunctionParams(allowModifiers, funcContextId);
    parseFunctionBodyAndFinish(functionStart, isGenerator, null /* allowExpressionBody */, funcContextId);
    const endTokenIndex = base_1.state.tokens.length;
    base_1.state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: true });
}
exports.parseMethod = parseMethod;
// Parse arrow function expression.
// If the parameters are provided, they will be converted to an
// assignable list.
function parseArrowExpression(functionStart, startTokenIndex) {
    parseFunctionBody(functionStart, false /* isGenerator */, true);
    const endTokenIndex = base_1.state.tokens.length;
    base_1.state.scopes.push({ startTokenIndex, endTokenIndex, isFunctionScope: true });
}
exports.parseArrowExpression = parseArrowExpression;
function parseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody = null, funcContextId) {
    if (base_1.hasPlugin("typescript")) {
        typescript_1.tsParseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody, funcContextId);
    }
    else if (base_1.hasPlugin("flow")) {
        flow_1.flowParseFunctionBodyAndFinish(functionStart, isGenerator, allowExpressionBody, funcContextId);
    }
    else {
        parseFunctionBody(functionStart, isGenerator, allowExpressionBody, funcContextId);
    }
}
exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;
// Parse function body and check parameters.
function parseFunctionBody(functionStart, isGenerator, allowExpression, funcContextId) {
    const isExpression = allowExpression && !tokenizer_1.match(4096 /* braceL */);
    if (isExpression) {
        parseMaybeAssign();
    }
    else {
        statement_1.parseBlock(true /* allowDirectives */, true /* isFunctionScope */, funcContextId);
    }
}
exports.parseFunctionBody = parseFunctionBody;
// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).
function parseExprList(close, allowEmpty = null) {
    let first = true;
    while (!tokenizer_1.eat(close)) {
        if (first) {
            first = false;
        }
        else {
            util_1.expect(7168 /* comma */);
            if (tokenizer_1.eat(close))
                break;
        }
        parseExprListItem(allowEmpty);
    }
}
function parseExprListItem(allowEmpty) {
    if (allowEmpty && tokenizer_1.match(7168 /* comma */)) {
        // Empty item; nothing more to parse for this item.
    }
    else if (tokenizer_1.match(11776 /* ellipsis */)) {
        lval_1.parseSpread();
        parseParenItem();
    }
    else {
        parseMaybeAssign(false, parseParenItem);
    }
}
// Parse the next token as an identifier.
function parseIdentifier() {
    tokenizer_1.next();
    base_1.state.tokens[base_1.state.tokens.length - 1].type = 2048 /* name */;
}
exports.parseIdentifier = parseIdentifier;
// Parses await expression inside async function.
function parseAwait() {
    parseMaybeUnary();
}
// Parses yield expression inside generator.
function parseYield() {
    tokenizer_1.next();
    if (!tokenizer_1.match(7680 /* semi */) && !util_1.canInsertSemicolon()) {
        tokenizer_1.eat(24587 /* star */);
        parseMaybeAssign();
    }
}
