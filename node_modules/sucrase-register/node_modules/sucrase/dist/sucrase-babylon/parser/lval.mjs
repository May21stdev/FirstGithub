import { flowParseAssignableListItemTypes } from "../plugins/flow";
import { tsParseAccessModifier, tsParseAssignableListItemTypes, tsParseModifier, } from "../plugins/typescript";
import { eat, IdentifierRole, match, next, runInTypeContext } from "../tokenizer";
import { hasPlugin, state } from "./base";
import { parseIdentifier, parseMaybeAssign, parseObj } from "./expression";
import { expect, unexpected } from "./util";
export function parseSpread() {
    next();
    parseMaybeAssign(false);
}
export function parseRest(isBlockScope) {
    next();
    parseBindingAtom(isBlockScope);
}
export function parseBindingIdentifier() {
    parseIdentifier();
}
// Parses lvalue (assignable) atom.
export function parseBindingAtom(isBlockScope) {
    switch (state.type) {
        case 40464 /* _this */:
            // In TypeScript, "this" may be the name of a parameter, so allow it.
            runInTypeContext(0, () => {
                next();
            });
            return;
        case 43536 /* _yield */:
        case 2048 /* name */: {
            state.type = 2048 /* name */;
            parseBindingIdentifier();
            state.tokens[state.tokens.length - 1].identifierRole = isBlockScope
                ? IdentifierRole.BlockScopedDeclaration
                : IdentifierRole.FunctionScopedDeclaration;
            return;
        }
        case 3072 /* bracketL */: {
            next();
            parseBindingList(3584 /* bracketR */, isBlockScope, true /* allowEmpty */);
            return;
        }
        case 4096 /* braceL */:
            parseObj(true, isBlockScope);
            return;
        default:
            throw unexpected();
    }
}
export function parseBindingList(close, isBlockScope, allowEmpty, allowModifiers = null) {
    let first = true;
    let hasRemovedComma = false;
    const firstItemTokenIndex = state.tokens.length;
    while (!eat(close)) {
        if (first) {
            first = false;
        }
        else {
            expect(7168 /* comma */);
            // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
            // a type token so that it will be removed.
            if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {
                state.tokens[state.tokens.length - 1].isType = true;
                hasRemovedComma = true;
            }
        }
        if (allowEmpty && match(7168 /* comma */)) {
            // Empty item; nothing further to parse for this item.
        }
        else if (eat(close)) {
            break;
        }
        else if (match(11776 /* ellipsis */)) {
            parseRest(isBlockScope);
            parseAssignableListItemTypes();
            expect(close);
            break;
        }
        else {
            parseAssignableListItem(allowModifiers, isBlockScope);
        }
    }
}
function parseAssignableListItem(allowModifiers, isBlockScope) {
    if (allowModifiers) {
        tsParseAccessModifier();
        tsParseModifier([26 /* _readonly */]);
    }
    parseMaybeDefault(isBlockScope);
    parseAssignableListItemTypes();
    parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);
}
function parseAssignableListItemTypes() {
    if (hasPlugin("flow")) {
        flowParseAssignableListItemTypes();
    }
    else if (hasPlugin("typescript")) {
        tsParseAssignableListItemTypes();
    }
}
// Parses assignment pattern around given atom if possible.
export function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
    if (!leftAlreadyParsed) {
        parseBindingAtom(isBlockScope);
    }
    if (!eat(14368 /* eq */)) {
        return;
    }
    parseMaybeAssign();
}
