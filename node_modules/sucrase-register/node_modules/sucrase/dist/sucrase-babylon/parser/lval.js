"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const flow_1 = require("../plugins/flow");
const typescript_1 = require("../plugins/typescript");
const tokenizer_1 = require("../tokenizer");
const base_1 = require("./base");
const expression_1 = require("./expression");
const util_1 = require("./util");
function parseSpread() {
    tokenizer_1.next();
    expression_1.parseMaybeAssign(false);
}
exports.parseSpread = parseSpread;
function parseRest(isBlockScope) {
    tokenizer_1.next();
    parseBindingAtom(isBlockScope);
}
exports.parseRest = parseRest;
function parseBindingIdentifier() {
    expression_1.parseIdentifier();
}
exports.parseBindingIdentifier = parseBindingIdentifier;
// Parses lvalue (assignable) atom.
function parseBindingAtom(isBlockScope) {
    switch (base_1.state.type) {
        case 40464 /* _this */:
            // In TypeScript, "this" may be the name of a parameter, so allow it.
            tokenizer_1.runInTypeContext(0, () => {
                tokenizer_1.next();
            });
            return;
        case 43536 /* _yield */:
        case 2048 /* name */: {
            base_1.state.type = 2048 /* name */;
            parseBindingIdentifier();
            base_1.state.tokens[base_1.state.tokens.length - 1].identifierRole = isBlockScope
                ? tokenizer_1.IdentifierRole.BlockScopedDeclaration
                : tokenizer_1.IdentifierRole.FunctionScopedDeclaration;
            return;
        }
        case 3072 /* bracketL */: {
            tokenizer_1.next();
            parseBindingList(3584 /* bracketR */, isBlockScope, true /* allowEmpty */);
            return;
        }
        case 4096 /* braceL */:
            expression_1.parseObj(true, isBlockScope);
            return;
        default:
            throw util_1.unexpected();
    }
}
exports.parseBindingAtom = parseBindingAtom;
function parseBindingList(close, isBlockScope, allowEmpty, allowModifiers = null) {
    let first = true;
    let hasRemovedComma = false;
    const firstItemTokenIndex = base_1.state.tokens.length;
    while (!tokenizer_1.eat(close)) {
        if (first) {
            first = false;
        }
        else {
            util_1.expect(7168 /* comma */);
            // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
            // a type token so that it will be removed.
            if (!hasRemovedComma && base_1.state.tokens[firstItemTokenIndex].isType) {
                base_1.state.tokens[base_1.state.tokens.length - 1].isType = true;
                hasRemovedComma = true;
            }
        }
        if (allowEmpty && tokenizer_1.match(7168 /* comma */)) {
            // Empty item; nothing further to parse for this item.
        }
        else if (tokenizer_1.eat(close)) {
            break;
        }
        else if (tokenizer_1.match(11776 /* ellipsis */)) {
            parseRest(isBlockScope);
            parseAssignableListItemTypes();
            util_1.expect(close);
            break;
        }
        else {
            parseAssignableListItem(allowModifiers, isBlockScope);
        }
    }
}
exports.parseBindingList = parseBindingList;
function parseAssignableListItem(allowModifiers, isBlockScope) {
    if (allowModifiers) {
        typescript_1.tsParseAccessModifier();
        typescript_1.tsParseModifier([26 /* _readonly */]);
    }
    parseMaybeDefault(isBlockScope);
    parseAssignableListItemTypes();
    parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);
}
function parseAssignableListItemTypes() {
    if (base_1.hasPlugin("flow")) {
        flow_1.flowParseAssignableListItemTypes();
    }
    else if (base_1.hasPlugin("typescript")) {
        typescript_1.tsParseAssignableListItemTypes();
    }
}
// Parses assignment pattern around given atom if possible.
function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
    if (!leftAlreadyParsed) {
        parseBindingAtom(isBlockScope);
    }
    if (!tokenizer_1.eat(14368 /* eq */)) {
        return;
    }
    expression_1.parseMaybeAssign();
}
exports.parseMaybeDefault = parseMaybeDefault;
