"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tokenizer_1 = require("../tokenizer");
const types_1 = require("../tokenizer/types");
const whitespace_1 = require("../util/whitespace");
const base_1 = require("./base");
// ## Parser utilities
// Tests whether parsed token is a contextual keyword.
function isContextual(contextualKeyword) {
    return base_1.state.contextualKeyword === contextualKeyword;
}
exports.isContextual = isContextual;
function isLookaheadContextual(contextualKeyword) {
    const l = tokenizer_1.lookaheadTypeAndKeyword();
    return l.type === 2048 /* name */ && l.contextualKeyword === contextualKeyword;
}
exports.isLookaheadContextual = isLookaheadContextual;
// Consumes contextual keyword if possible.
function eatContextual(contextualKeyword) {
    return base_1.state.contextualKeyword === contextualKeyword && tokenizer_1.eat(2048 /* name */);
}
exports.eatContextual = eatContextual;
// Asserts that following token is given contextual keyword.
function expectContextual(contextualKeyword) {
    if (!eatContextual(contextualKeyword)) {
        unexpected(null);
    }
}
exports.expectContextual = expectContextual;
// Test whether a semicolon can be inserted at the current position.
function canInsertSemicolon() {
    return tokenizer_1.match(2560 /* eof */) || tokenizer_1.match(5120 /* braceR */) || hasPrecedingLineBreak();
}
exports.canInsertSemicolon = canInsertSemicolon;
function hasPrecedingLineBreak() {
    const prevToken = base_1.state.tokens[base_1.state.tokens.length - 1];
    const lastTokEnd = prevToken ? prevToken.end : 0;
    return whitespace_1.lineBreak.test(base_1.input.slice(lastTokEnd, base_1.state.start));
}
exports.hasPrecedingLineBreak = hasPrecedingLineBreak;
function isLineTerminator() {
    return tokenizer_1.eat(7680 /* semi */) || canInsertSemicolon();
}
exports.isLineTerminator = isLineTerminator;
// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
function semicolon() {
    if (!isLineTerminator())
        unexpected(null, 7680 /* semi */);
}
exports.semicolon = semicolon;
// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.
function expect(type, pos) {
    const matched = tokenizer_1.eat(type);
    if (!matched) {
        unexpected(pos, type);
    }
}
exports.expect = expect;
// Raise an unexpected token error. Can take the expected token type
// instead of a message string.
function unexpected(pos = null, messageOrType = "Unexpected token") {
    if (typeof messageOrType !== "string") {
        messageOrType = `Unexpected token, expected "${types_1.formatTokenType(messageOrType)}"`;
    }
    throw base_1.raise(pos != null ? pos : base_1.state.start, messageOrType);
}
exports.unexpected = unexpected;
