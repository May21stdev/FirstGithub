/* eslint max-len: 0 */
import { hasPlugin, input, raise, state } from "../parser/base";
import { unexpected } from "../parser/util";
import { isIdentifierChar, isIdentifierStart } from "../util/identifier";
import { nonASCIIwhitespace } from "../util/whitespace";
import readWord from "./readWord";
export var IdentifierRole;
(function (IdentifierRole) {
    IdentifierRole[IdentifierRole["Access"] = 0] = "Access";
    IdentifierRole[IdentifierRole["ExportAccess"] = 1] = "ExportAccess";
    IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = 2] = "FunctionScopedDeclaration";
    IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = 3] = "BlockScopedDeclaration";
    IdentifierRole[IdentifierRole["ObjectShorthand"] = 4] = "ObjectShorthand";
    IdentifierRole[IdentifierRole["ObjectKey"] = 5] = "ObjectKey";
})(IdentifierRole || (IdentifierRole = {}));
// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
export class Token {
    constructor() {
        this.type = state.type;
        this.contextualKeyword = state.contextualKeyword;
        this.start = state.start;
        this.end = state.end;
        this.isType = state.isType;
        this.identifierRole = null;
        this.shadowsGlobal = null;
        this.contextId = null;
        this.rhsEndIndex = null;
        this.isExpression = null;
    }
}
// ## Tokenizer
// Move to the next token
export function next() {
    state.tokens.push(new Token());
    nextToken();
}
// Call instead of next when inside a template, since that needs to be handled differently.
export function nextTemplateToken() {
    state.tokens.push(new Token());
    state.start = state.pos;
    readTmplToken();
}
// The tokenizer never parses regexes by default. Instead, the parser is responsible for
// instructing it to parse a regex when we see a slash at the start of an expression.
export function retokenizeSlashAsRegex() {
    if (state.type === 14880 /* assign */) {
        --state.pos;
    }
    readRegexp();
}
export function runInTypeContext(existingTokensInType, func) {
    for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {
        state.tokens[i].isType = true;
    }
    const oldIsType = state.isType;
    state.isType = true;
    const result = func();
    state.isType = oldIsType;
    return result;
}
export function eat(type) {
    if (match(type)) {
        next();
        return true;
    }
    else {
        return false;
    }
}
export function match(type) {
    return state.type === type;
}
export function lookaheadType() {
    const snapshot = state.snapshot();
    next();
    const type = state.type;
    state.restoreFromSnapshot(snapshot);
    return type;
}
export function lookaheadTypeAndKeyword() {
    const snapshot = state.snapshot();
    next();
    const type = state.type;
    const contextualKeyword = state.contextualKeyword;
    state.restoreFromSnapshot(snapshot);
    return { type, contextualKeyword };
}
// Read a single token, updating the parser object's token-related
// properties.
export function nextToken() {
    skipSpace();
    state.start = state.pos;
    if (state.pos >= input.length) {
        const tokens = state.tokens;
        // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
        // Also check the token positions rather than the types since sometimes we rewrite the token
        // type to something else.
        if (tokens.length >= 2 &&
            tokens[tokens.length - 1].start >= input.length &&
            tokens[tokens.length - 2].start >= input.length) {
            unexpected(null, "Unexpectedly reached the end of input.");
        }
        finishToken(2560 /* eof */);
        return;
    }
    readToken(input.charCodeAt(state.pos));
}
function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) ||
        code === 92 /* backslash */ ||
        (code === 64 /* atSign */ && input.charCodeAt(state.pos + 1) === 64 /* atSign */)) {
        readWord();
    }
    else {
        getTokenFromCode(code);
    }
}
function skipBlockComment() {
    const end = input.indexOf("*/", (state.pos += 2));
    if (end === -1)
        raise(state.pos - 2, "Unterminated comment");
    state.pos = end + 2;
}
export function skipLineComment(startSkip) {
    let ch = input.charCodeAt((state.pos += startSkip));
    if (state.pos < input.length) {
        while (ch !== 10 /* lineFeed */ &&
            ch !== 13 /* carriageReturn */ &&
            ch !== 8232 /* lineSeparator */ &&
            ch !== 8233 /* paragraphSeparator */ &&
            ++state.pos < input.length) {
            ch = input.charCodeAt(state.pos);
        }
    }
}
// Called at the start of the parse and after every token. Skips
// whitespace and comments.
export function skipSpace() {
    loop: while (state.pos < input.length) {
        const ch = input.charCodeAt(state.pos);
        switch (ch) {
            case 32 /* space */:
            case 160 /* nonBreakingSpace */:
                ++state.pos;
                break;
            case 13 /* carriageReturn */:
                if (input.charCodeAt(state.pos + 1) === 10 /* lineFeed */) {
                    ++state.pos;
                }
            case 10 /* lineFeed */:
            case 8232 /* lineSeparator */:
            case 8233 /* paragraphSeparator */:
                ++state.pos;
                break;
            case 47 /* slash */:
                switch (input.charCodeAt(state.pos + 1)) {
                    case 42 /* asterisk */:
                        skipBlockComment();
                        break;
                    case 47 /* slash */:
                        skipLineComment(2);
                        break;
                    default:
                        break loop;
                }
                break;
            default:
                if ((ch > 8 /* backSpace */ && ch < 14 /* shiftOut */) ||
                    (ch >= 5760 /* oghamSpaceMark */ && nonASCIIwhitespace.test(String.fromCharCode(ch)))) {
                    ++state.pos;
                }
                else {
                    break loop;
                }
        }
    }
}
// Called at the end of every token. Sets various fields, and skips the space after the token, so
// that the next one's `start` will point at the right position.
export function finishToken(type, contextualKeyword = 0 /* NONE */) {
    state.end = state.pos;
    state.type = type;
    state.contextualKeyword = contextualKeyword;
}
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar >= 48 /* digit0 */ && nextChar <= 57 /* digit9 */) {
        readNumber(true);
        return;
    }
    const next2 = input.charCodeAt(state.pos + 2);
    if (nextChar === 46 /* dot */ && next2 === 46 /* dot */) {
        state.pos += 3;
        finishToken(11776 /* ellipsis */);
    }
    else {
        ++state.pos;
        finishToken(9216 /* dot */);
    }
}
function readToken_slash() {
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
    }
    else {
        finishOp(25099 /* slash */, 1);
    }
}
function readToken_mult_modulo(code) {
    // '%*'
    let type = code === 42 /* asterisk */ ? 24587 /* star */ : 24075 /* modulo */;
    let width = 1;
    let nextChar = input.charCodeAt(state.pos + 1);
    // Exponentiation operator **
    if (code === 42 /* asterisk */ && nextChar === 42 /* asterisk */) {
        width++;
        nextChar = input.charCodeAt(state.pos + 2);
        type = 25676 /* exponent */;
    }
    // Match *= or %=, disallowing *=> which can be valid in flow.
    if (nextChar === 61 /* equalsTo */ &&
        input.charCodeAt(state.pos + 2) !== 62 /* greaterThan */) {
        width++;
        type = 14880 /* assign */;
    }
    finishOp(type, width);
}
function readToken_pipe_amp(code) {
    // '|&'
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar === code) {
        if (input.charCodeAt(state.pos + 2) === 61 /* equalsTo */) {
            // ||= or &&=
            finishOp(14880 /* assign */, 3);
        }
        else {
            // || or &&
            finishOp(code === 124 /* verticalBar */ ? 17922 /* logicalOR */ : 18435 /* logicalAND */, 2);
        }
        return;
    }
    if (code === 124 /* verticalBar */) {
        // '|>'
        if (nextChar === 62 /* greaterThan */) {
            finishOp(16897 /* pipeline */, 2);
            return;
        }
        else if (nextChar === 125 /* rightCurlyBrace */ && hasPlugin("flow")) {
            // '|}'
            finishOp(5632 /* braceBarR */, 2);
            return;
        }
    }
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
        return;
    }
    finishOp(code === 124 /* verticalBar */ ? 18948 /* bitwiseOR */ : 19974 /* bitwiseAND */, 1);
}
function readToken_caret() {
    // '^'
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
    }
    else {
        finishOp(19461 /* bitwiseXOR */, 1);
    }
}
function readToken_plus_min(code) {
    // '+-'
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar === code) {
        finishOp(15744 /* incDec */, 2);
        return;
    }
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
    }
    else if (code === 43 /* plusSign */) {
        finishOp(23178 /* plus */, 1);
    }
    else {
        finishOp(23690 /* minus */, 1);
    }
}
// '<>'
function readToken_lt_gt(code) {
    // Avoid right-shift for things like Array<Array<string>>.
    if (code === 62 /* greaterThan */ && state.isType) {
        finishOp(21512 /* greaterThan */, 1);
        return;
    }
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar === code) {
        const size = code === 62 /* greaterThan */ && input.charCodeAt(state.pos + 2) === 62 /* greaterThan */
            ? 3
            : 2;
        if (input.charCodeAt(state.pos + size) === 61 /* equalsTo */) {
            finishOp(14880 /* assign */, size + 1);
            return;
        }
        finishOp(22537 /* bitShift */, size);
        return;
    }
    if (nextChar === 61 /* equalsTo */) {
        // <= | >=
        finishOp(22024 /* relationalOrEqual */, 2);
    }
    else if (code === 60 /* lessThan */) {
        finishOp(21000 /* lessThan */, 1);
    }
    else {
        finishOp(21512 /* greaterThan */, 1);
    }
}
function readToken_eq_excl(code) {
    // '=!'
    const nextChar = input.charCodeAt(state.pos + 1);
    if (nextChar === 61 /* equalsTo */) {
        finishOp(20487 /* equality */, input.charCodeAt(state.pos + 2) === 61 /* equalsTo */ ? 3 : 2);
        return;
    }
    if (code === 61 /* equalsTo */ && nextChar === 62 /* greaterThan */) {
        // '=>'
        state.pos += 2;
        finishToken(10752 /* arrow */);
        return;
    }
    finishOp(code === 61 /* equalsTo */ ? 14368 /* eq */ : 16000 /* bang */, 1);
}
function readToken_question() {
    // '?'
    const nextChar = input.charCodeAt(state.pos + 1);
    const nextChar2 = input.charCodeAt(state.pos + 2);
    if (nextChar === 63 /* questionMark */) {
        if (nextChar2 === 61 /* equalsTo */) {
            // '??='
            finishOp(14880 /* assign */, 3);
        }
        else {
            // '??'
            finishOp(17410 /* nullishCoalescing */, 2);
        }
    }
    else if (nextChar === 46 /* dot */ &&
        !(nextChar2 >= 48 /* digit0 */ && nextChar2 <= 57 /* digit9 */)) {
        // '.' not followed by a number
        state.pos += 2;
        finishToken(10240 /* questionDot */);
    }
    else {
        ++state.pos;
        finishToken(9728 /* question */);
    }
}
export function getTokenFromCode(code) {
    switch (code) {
        case 35 /* numberSign */:
            ++state.pos;
            finishToken(13824 /* hash */);
            return;
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46 /* dot */:
            readToken_dot();
            return;
        // Punctuation tokens.
        case 40 /* leftParenthesis */:
            ++state.pos;
            finishToken(6144 /* parenL */);
            return;
        case 41 /* rightParenthesis */:
            ++state.pos;
            finishToken(6656 /* parenR */);
            return;
        case 59 /* semicolon */:
            ++state.pos;
            finishToken(7680 /* semi */);
            return;
        case 44 /* comma */:
            ++state.pos;
            finishToken(7168 /* comma */);
            return;
        case 91 /* leftSquareBracket */:
            ++state.pos;
            finishToken(3072 /* bracketL */);
            return;
        case 93 /* rightSquareBracket */:
            ++state.pos;
            finishToken(3584 /* bracketR */);
            return;
        case 123 /* leftCurlyBrace */:
            if (hasPlugin("flow") && input.charCodeAt(state.pos + 1) === 124 /* verticalBar */) {
                finishOp(4608 /* braceBarL */, 2);
            }
            else {
                ++state.pos;
                finishToken(4096 /* braceL */);
            }
            return;
        case 125 /* rightCurlyBrace */:
            ++state.pos;
            finishToken(5120 /* braceR */);
            return;
        case 58 /* colon */:
            if (input.charCodeAt(state.pos + 1) === 58 /* colon */) {
                finishOp(8704 /* doubleColon */, 2);
            }
            else {
                ++state.pos;
                finishToken(8192 /* colon */);
            }
            return;
        case 63 /* questionMark */:
            readToken_question();
            return;
        case 64 /* atSign */:
            ++state.pos;
            finishToken(13312 /* at */);
            return;
        case 96 /* graveAccent */:
            ++state.pos;
            finishToken(12288 /* backQuote */);
            return;
        case 48 /* digit0 */: {
            const nextChar = input.charCodeAt(state.pos + 1);
            // '0x', '0X', '0o', '0O', '0b', '0B'
            if (nextChar === 120 /* lowercaseX */ ||
                nextChar === 88 /* uppercaseX */ ||
                nextChar === 111 /* lowercaseO */ ||
                nextChar === 79 /* uppercaseO */ ||
                nextChar === 98 /* lowercaseB */ ||
                nextChar === 66 /* uppercaseB */) {
                readRadixNumber();
                return;
            }
        }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49 /* digit1 */:
        case 50 /* digit2 */:
        case 51 /* digit3 */:
        case 52 /* digit4 */:
        case 53 /* digit5 */:
        case 54 /* digit6 */:
        case 55 /* digit7 */:
        case 56 /* digit8 */:
        case 57 /* digit9 */:
            readNumber(false);
            return;
        // Quotes produce strings.
        case 34 /* quotationMark */:
        case 39 /* apostrophe */:
            readString(code);
            return;
        // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
        case 47 /* slash */:
            readToken_slash();
            return;
        case 37 /* percentSign */:
        case 42 /* asterisk */:
            readToken_mult_modulo(code);
            return;
        case 124 /* verticalBar */:
        case 38 /* ampersand */:
            readToken_pipe_amp(code);
            return;
        case 94 /* caret */:
            readToken_caret();
            return;
        case 43 /* plusSign */:
        case 45 /* dash */:
            readToken_plus_min(code);
            return;
        case 60 /* lessThan */:
        case 62 /* greaterThan */:
            readToken_lt_gt(code);
            return;
        case 61 /* equalsTo */:
        case 33 /* exclamationMark */:
            readToken_eq_excl(code);
            return;
        case 126 /* tilde */:
            finishOp(16512 /* tilde */, 1);
            return;
        default:
            break;
    }
    raise(state.pos, `Unexpected character '${String.fromCharCode(code)}'`);
}
function finishOp(type, size) {
    state.pos += size;
    finishToken(type);
}
function readRegexp() {
    const start = state.pos;
    let escaped;
    let inClass;
    for (;;) {
        if (state.pos >= input.length) {
            raise(start, "Unterminated regular expression");
        }
        const ch = input.charAt(state.pos);
        if (escaped) {
            escaped = false;
        }
        else {
            if (ch === "[") {
                inClass = true;
            }
            else if (ch === "]" && inClass) {
                inClass = false;
            }
            else if (ch === "/" && !inClass) {
                break;
            }
            escaped = ch === "\\";
        }
        ++state.pos;
    }
    ++state.pos;
    // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
    skipWord();
    finishToken(1024 /* regexp */);
}
// Read an integer. We allow any valid digit, including hex digits, plus numeric separators, and
// stop at any other character.
function readInt() {
    while (true) {
        const code = input.charCodeAt(state.pos);
        if ((code >= 48 /* digit0 */ && code <= 57 /* digit9 */) ||
            (code >= 97 /* lowercaseA */ && code <= 102 /* lowercaseF */) ||
            (code >= 65 /* uppercaseA */ && code <= 70 /* uppercaseF */) ||
            code === 95 /* underscore */) {
            state.pos++;
        }
        else {
            break;
        }
    }
}
function readRadixNumber() {
    let isBigInt = false;
    state.pos += 2; // 0x
    readInt();
    if (input.charCodeAt(state.pos) === 110 /* lowercaseN */) {
        ++state.pos;
        isBigInt = true;
    }
    if (isBigInt) {
        finishToken(512 /* bigint */);
        return;
    }
    finishToken(0 /* num */);
}
// Read an integer, octal integer, or floating-point number.
function readNumber(startsWithDot) {
    let isBigInt = false;
    if (!startsWithDot) {
        readInt();
    }
    let nextChar = input.charCodeAt(state.pos);
    if (nextChar === 46 /* dot */) {
        ++state.pos;
        readInt();
        nextChar = input.charCodeAt(state.pos);
    }
    if (nextChar === 69 /* uppercaseE */ || nextChar === 101 /* lowercaseE */) {
        nextChar = input.charCodeAt(++state.pos);
        if (nextChar === 43 /* plusSign */ || nextChar === 45 /* dash */) {
            ++state.pos;
        }
        readInt();
        nextChar = input.charCodeAt(state.pos);
    }
    if (nextChar === 110 /* lowercaseN */) {
        ++state.pos;
        isBigInt = true;
    }
    if (isBigInt) {
        finishToken(512 /* bigint */);
        return;
    }
    finishToken(0 /* num */);
}
function readString(quote) {
    state.pos++;
    for (;;) {
        if (state.pos >= input.length) {
            raise(state.start, "Unterminated string constant");
        }
        const ch = input.charCodeAt(state.pos);
        if (ch === 92 /* backslash */) {
            state.pos++;
        }
        else if (ch === quote) {
            break;
        }
        state.pos++;
    }
    state.pos++;
    finishToken(1536 /* string */);
}
// Reads template string tokens.
function readTmplToken() {
    for (;;) {
        if (state.pos >= input.length) {
            raise(state.start, "Unterminated template");
        }
        const ch = input.charCodeAt(state.pos);
        if (ch === 96 /* graveAccent */ ||
            (ch === 36 /* dollarSign */ && input.charCodeAt(state.pos + 1) === 123 /* leftCurlyBrace */)) {
            if (state.pos === state.start && match(11264 /* template */)) {
                if (ch === 36 /* dollarSign */) {
                    state.pos += 2;
                    finishToken(12800 /* dollarBraceL */);
                    return;
                }
                else {
                    ++state.pos;
                    finishToken(12288 /* backQuote */);
                    return;
                }
            }
            finishToken(11264 /* template */);
            return;
        }
        if (ch === 92 /* backslash */) {
            state.pos++;
        }
        state.pos++;
    }
}
// Skip to the end of the current word. Note that this is the same as the snippet at the end of
// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
// measurements.
export function skipWord() {
    while (state.pos < input.length) {
        const ch = input.charCodeAt(state.pos);
        if (isIdentifierChar(ch)) {
            state.pos++;
        }
        else if (ch === 92 /* backslash */) {
            // \u
            state.pos += 2;
            if (input.charCodeAt(state.pos) === 123 /* leftCurlyBrace */) {
                while (input.charCodeAt(state.pos) !== 123 /* leftCurlyBrace */) {
                    state.pos++;
                }
                state.pos++;
            }
        }
        else {
            break;
        }
    }
}
