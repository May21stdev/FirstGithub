"use strict";
/* eslint max-len: 0 */
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../parser/base");
const util_1 = require("../parser/util");
const identifier_1 = require("../util/identifier");
const whitespace_1 = require("../util/whitespace");
const readWord_1 = require("./readWord");
var IdentifierRole;
(function (IdentifierRole) {
    IdentifierRole[IdentifierRole["Access"] = 0] = "Access";
    IdentifierRole[IdentifierRole["ExportAccess"] = 1] = "ExportAccess";
    IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = 2] = "FunctionScopedDeclaration";
    IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = 3] = "BlockScopedDeclaration";
    IdentifierRole[IdentifierRole["ObjectShorthand"] = 4] = "ObjectShorthand";
    IdentifierRole[IdentifierRole["ObjectKey"] = 5] = "ObjectKey";
})(IdentifierRole = exports.IdentifierRole || (exports.IdentifierRole = {}));
// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
class Token {
    constructor() {
        this.type = base_1.state.type;
        this.contextualKeyword = base_1.state.contextualKeyword;
        this.start = base_1.state.start;
        this.end = base_1.state.end;
        this.isType = base_1.state.isType;
        this.identifierRole = null;
        this.shadowsGlobal = null;
        this.contextId = null;
        this.rhsEndIndex = null;
        this.isExpression = null;
    }
}
exports.Token = Token;
// ## Tokenizer
// Move to the next token
function next() {
    base_1.state.tokens.push(new Token());
    nextToken();
}
exports.next = next;
// Call instead of next when inside a template, since that needs to be handled differently.
function nextTemplateToken() {
    base_1.state.tokens.push(new Token());
    base_1.state.start = base_1.state.pos;
    readTmplToken();
}
exports.nextTemplateToken = nextTemplateToken;
// The tokenizer never parses regexes by default. Instead, the parser is responsible for
// instructing it to parse a regex when we see a slash at the start of an expression.
function retokenizeSlashAsRegex() {
    if (base_1.state.type === 14880 /* assign */) {
        --base_1.state.pos;
    }
    readRegexp();
}
exports.retokenizeSlashAsRegex = retokenizeSlashAsRegex;
function runInTypeContext(existingTokensInType, func) {
    for (let i = base_1.state.tokens.length - existingTokensInType; i < base_1.state.tokens.length; i++) {
        base_1.state.tokens[i].isType = true;
    }
    const oldIsType = base_1.state.isType;
    base_1.state.isType = true;
    const result = func();
    base_1.state.isType = oldIsType;
    return result;
}
exports.runInTypeContext = runInTypeContext;
function eat(type) {
    if (match(type)) {
        next();
        return true;
    }
    else {
        return false;
    }
}
exports.eat = eat;
function match(type) {
    return base_1.state.type === type;
}
exports.match = match;
function lookaheadType() {
    const snapshot = base_1.state.snapshot();
    next();
    const type = base_1.state.type;
    base_1.state.restoreFromSnapshot(snapshot);
    return type;
}
exports.lookaheadType = lookaheadType;
function lookaheadTypeAndKeyword() {
    const snapshot = base_1.state.snapshot();
    next();
    const type = base_1.state.type;
    const contextualKeyword = base_1.state.contextualKeyword;
    base_1.state.restoreFromSnapshot(snapshot);
    return { type, contextualKeyword };
}
exports.lookaheadTypeAndKeyword = lookaheadTypeAndKeyword;
// Read a single token, updating the parser object's token-related
// properties.
function nextToken() {
    skipSpace();
    base_1.state.start = base_1.state.pos;
    if (base_1.state.pos >= base_1.input.length) {
        const tokens = base_1.state.tokens;
        // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
        // Also check the token positions rather than the types since sometimes we rewrite the token
        // type to something else.
        if (tokens.length >= 2 &&
            tokens[tokens.length - 1].start >= base_1.input.length &&
            tokens[tokens.length - 2].start >= base_1.input.length) {
            util_1.unexpected(null, "Unexpectedly reached the end of input.");
        }
        finishToken(2560 /* eof */);
        return;
    }
    readToken(base_1.input.charCodeAt(base_1.state.pos));
}
exports.nextToken = nextToken;
function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (identifier_1.isIdentifierStart(code) ||
        code === 92 /* backslash */ ||
        (code === 64 /* atSign */ && base_1.input.charCodeAt(base_1.state.pos + 1) === 64 /* atSign */)) {
        readWord_1.default();
    }
    else {
        getTokenFromCode(code);
    }
}
function skipBlockComment() {
    const end = base_1.input.indexOf("*/", (base_1.state.pos += 2));
    if (end === -1)
        base_1.raise(base_1.state.pos - 2, "Unterminated comment");
    base_1.state.pos = end + 2;
}
function skipLineComment(startSkip) {
    let ch = base_1.input.charCodeAt((base_1.state.pos += startSkip));
    if (base_1.state.pos < base_1.input.length) {
        while (ch !== 10 /* lineFeed */ &&
            ch !== 13 /* carriageReturn */ &&
            ch !== 8232 /* lineSeparator */ &&
            ch !== 8233 /* paragraphSeparator */ &&
            ++base_1.state.pos < base_1.input.length) {
            ch = base_1.input.charCodeAt(base_1.state.pos);
        }
    }
}
exports.skipLineComment = skipLineComment;
// Called at the start of the parse and after every token. Skips
// whitespace and comments.
function skipSpace() {
    loop: while (base_1.state.pos < base_1.input.length) {
        const ch = base_1.input.charCodeAt(base_1.state.pos);
        switch (ch) {
            case 32 /* space */:
            case 160 /* nonBreakingSpace */:
                ++base_1.state.pos;
                break;
            case 13 /* carriageReturn */:
                if (base_1.input.charCodeAt(base_1.state.pos + 1) === 10 /* lineFeed */) {
                    ++base_1.state.pos;
                }
            case 10 /* lineFeed */:
            case 8232 /* lineSeparator */:
            case 8233 /* paragraphSeparator */:
                ++base_1.state.pos;
                break;
            case 47 /* slash */:
                switch (base_1.input.charCodeAt(base_1.state.pos + 1)) {
                    case 42 /* asterisk */:
                        skipBlockComment();
                        break;
                    case 47 /* slash */:
                        skipLineComment(2);
                        break;
                    default:
                        break loop;
                }
                break;
            default:
                if ((ch > 8 /* backSpace */ && ch < 14 /* shiftOut */) ||
                    (ch >= 5760 /* oghamSpaceMark */ && whitespace_1.nonASCIIwhitespace.test(String.fromCharCode(ch)))) {
                    ++base_1.state.pos;
                }
                else {
                    break loop;
                }
        }
    }
}
exports.skipSpace = skipSpace;
// Called at the end of every token. Sets various fields, and skips the space after the token, so
// that the next one's `start` will point at the right position.
function finishToken(type, contextualKeyword = 0 /* NONE */) {
    base_1.state.end = base_1.state.pos;
    base_1.state.type = type;
    base_1.state.contextualKeyword = contextualKeyword;
}
exports.finishToken = finishToken;
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar >= 48 /* digit0 */ && nextChar <= 57 /* digit9 */) {
        readNumber(true);
        return;
    }
    const next2 = base_1.input.charCodeAt(base_1.state.pos + 2);
    if (nextChar === 46 /* dot */ && next2 === 46 /* dot */) {
        base_1.state.pos += 3;
        finishToken(11776 /* ellipsis */);
    }
    else {
        ++base_1.state.pos;
        finishToken(9216 /* dot */);
    }
}
function readToken_slash() {
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
    }
    else {
        finishOp(25099 /* slash */, 1);
    }
}
function readToken_mult_modulo(code) {
    // '%*'
    let type = code === 42 /* asterisk */ ? 24587 /* star */ : 24075 /* modulo */;
    let width = 1;
    let nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    // Exponentiation operator **
    if (code === 42 /* asterisk */ && nextChar === 42 /* asterisk */) {
        width++;
        nextChar = base_1.input.charCodeAt(base_1.state.pos + 2);
        type = 25676 /* exponent */;
    }
    // Match *= or %=, disallowing *=> which can be valid in flow.
    if (nextChar === 61 /* equalsTo */ &&
        base_1.input.charCodeAt(base_1.state.pos + 2) !== 62 /* greaterThan */) {
        width++;
        type = 14880 /* assign */;
    }
    finishOp(type, width);
}
function readToken_pipe_amp(code) {
    // '|&'
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar === code) {
        if (base_1.input.charCodeAt(base_1.state.pos + 2) === 61 /* equalsTo */) {
            // ||= or &&=
            finishOp(14880 /* assign */, 3);
        }
        else {
            // || or &&
            finishOp(code === 124 /* verticalBar */ ? 17922 /* logicalOR */ : 18435 /* logicalAND */, 2);
        }
        return;
    }
    if (code === 124 /* verticalBar */) {
        // '|>'
        if (nextChar === 62 /* greaterThan */) {
            finishOp(16897 /* pipeline */, 2);
            return;
        }
        else if (nextChar === 125 /* rightCurlyBrace */ && base_1.hasPlugin("flow")) {
            // '|}'
            finishOp(5632 /* braceBarR */, 2);
            return;
        }
    }
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
        return;
    }
    finishOp(code === 124 /* verticalBar */ ? 18948 /* bitwiseOR */ : 19974 /* bitwiseAND */, 1);
}
function readToken_caret() {
    // '^'
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
    }
    else {
        finishOp(19461 /* bitwiseXOR */, 1);
    }
}
function readToken_plus_min(code) {
    // '+-'
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar === code) {
        finishOp(15744 /* incDec */, 2);
        return;
    }
    if (nextChar === 61 /* equalsTo */) {
        finishOp(14880 /* assign */, 2);
    }
    else if (code === 43 /* plusSign */) {
        finishOp(23178 /* plus */, 1);
    }
    else {
        finishOp(23690 /* minus */, 1);
    }
}
// '<>'
function readToken_lt_gt(code) {
    // Avoid right-shift for things like Array<Array<string>>.
    if (code === 62 /* greaterThan */ && base_1.state.isType) {
        finishOp(21512 /* greaterThan */, 1);
        return;
    }
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar === code) {
        const size = code === 62 /* greaterThan */ && base_1.input.charCodeAt(base_1.state.pos + 2) === 62 /* greaterThan */
            ? 3
            : 2;
        if (base_1.input.charCodeAt(base_1.state.pos + size) === 61 /* equalsTo */) {
            finishOp(14880 /* assign */, size + 1);
            return;
        }
        finishOp(22537 /* bitShift */, size);
        return;
    }
    if (nextChar === 61 /* equalsTo */) {
        // <= | >=
        finishOp(22024 /* relationalOrEqual */, 2);
    }
    else if (code === 60 /* lessThan */) {
        finishOp(21000 /* lessThan */, 1);
    }
    else {
        finishOp(21512 /* greaterThan */, 1);
    }
}
function readToken_eq_excl(code) {
    // '=!'
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    if (nextChar === 61 /* equalsTo */) {
        finishOp(20487 /* equality */, base_1.input.charCodeAt(base_1.state.pos + 2) === 61 /* equalsTo */ ? 3 : 2);
        return;
    }
    if (code === 61 /* equalsTo */ && nextChar === 62 /* greaterThan */) {
        // '=>'
        base_1.state.pos += 2;
        finishToken(10752 /* arrow */);
        return;
    }
    finishOp(code === 61 /* equalsTo */ ? 14368 /* eq */ : 16000 /* bang */, 1);
}
function readToken_question() {
    // '?'
    const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
    const nextChar2 = base_1.input.charCodeAt(base_1.state.pos + 2);
    if (nextChar === 63 /* questionMark */) {
        if (nextChar2 === 61 /* equalsTo */) {
            // '??='
            finishOp(14880 /* assign */, 3);
        }
        else {
            // '??'
            finishOp(17410 /* nullishCoalescing */, 2);
        }
    }
    else if (nextChar === 46 /* dot */ &&
        !(nextChar2 >= 48 /* digit0 */ && nextChar2 <= 57 /* digit9 */)) {
        // '.' not followed by a number
        base_1.state.pos += 2;
        finishToken(10240 /* questionDot */);
    }
    else {
        ++base_1.state.pos;
        finishToken(9728 /* question */);
    }
}
function getTokenFromCode(code) {
    switch (code) {
        case 35 /* numberSign */:
            ++base_1.state.pos;
            finishToken(13824 /* hash */);
            return;
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46 /* dot */:
            readToken_dot();
            return;
        // Punctuation tokens.
        case 40 /* leftParenthesis */:
            ++base_1.state.pos;
            finishToken(6144 /* parenL */);
            return;
        case 41 /* rightParenthesis */:
            ++base_1.state.pos;
            finishToken(6656 /* parenR */);
            return;
        case 59 /* semicolon */:
            ++base_1.state.pos;
            finishToken(7680 /* semi */);
            return;
        case 44 /* comma */:
            ++base_1.state.pos;
            finishToken(7168 /* comma */);
            return;
        case 91 /* leftSquareBracket */:
            ++base_1.state.pos;
            finishToken(3072 /* bracketL */);
            return;
        case 93 /* rightSquareBracket */:
            ++base_1.state.pos;
            finishToken(3584 /* bracketR */);
            return;
        case 123 /* leftCurlyBrace */:
            if (base_1.hasPlugin("flow") && base_1.input.charCodeAt(base_1.state.pos + 1) === 124 /* verticalBar */) {
                finishOp(4608 /* braceBarL */, 2);
            }
            else {
                ++base_1.state.pos;
                finishToken(4096 /* braceL */);
            }
            return;
        case 125 /* rightCurlyBrace */:
            ++base_1.state.pos;
            finishToken(5120 /* braceR */);
            return;
        case 58 /* colon */:
            if (base_1.input.charCodeAt(base_1.state.pos + 1) === 58 /* colon */) {
                finishOp(8704 /* doubleColon */, 2);
            }
            else {
                ++base_1.state.pos;
                finishToken(8192 /* colon */);
            }
            return;
        case 63 /* questionMark */:
            readToken_question();
            return;
        case 64 /* atSign */:
            ++base_1.state.pos;
            finishToken(13312 /* at */);
            return;
        case 96 /* graveAccent */:
            ++base_1.state.pos;
            finishToken(12288 /* backQuote */);
            return;
        case 48 /* digit0 */: {
            const nextChar = base_1.input.charCodeAt(base_1.state.pos + 1);
            // '0x', '0X', '0o', '0O', '0b', '0B'
            if (nextChar === 120 /* lowercaseX */ ||
                nextChar === 88 /* uppercaseX */ ||
                nextChar === 111 /* lowercaseO */ ||
                nextChar === 79 /* uppercaseO */ ||
                nextChar === 98 /* lowercaseB */ ||
                nextChar === 66 /* uppercaseB */) {
                readRadixNumber();
                return;
            }
        }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49 /* digit1 */:
        case 50 /* digit2 */:
        case 51 /* digit3 */:
        case 52 /* digit4 */:
        case 53 /* digit5 */:
        case 54 /* digit6 */:
        case 55 /* digit7 */:
        case 56 /* digit8 */:
        case 57 /* digit9 */:
            readNumber(false);
            return;
        // Quotes produce strings.
        case 34 /* quotationMark */:
        case 39 /* apostrophe */:
            readString(code);
            return;
        // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
        case 47 /* slash */:
            readToken_slash();
            return;
        case 37 /* percentSign */:
        case 42 /* asterisk */:
            readToken_mult_modulo(code);
            return;
        case 124 /* verticalBar */:
        case 38 /* ampersand */:
            readToken_pipe_amp(code);
            return;
        case 94 /* caret */:
            readToken_caret();
            return;
        case 43 /* plusSign */:
        case 45 /* dash */:
            readToken_plus_min(code);
            return;
        case 60 /* lessThan */:
        case 62 /* greaterThan */:
            readToken_lt_gt(code);
            return;
        case 61 /* equalsTo */:
        case 33 /* exclamationMark */:
            readToken_eq_excl(code);
            return;
        case 126 /* tilde */:
            finishOp(16512 /* tilde */, 1);
            return;
        default:
            break;
    }
    base_1.raise(base_1.state.pos, `Unexpected character '${String.fromCharCode(code)}'`);
}
exports.getTokenFromCode = getTokenFromCode;
function finishOp(type, size) {
    base_1.state.pos += size;
    finishToken(type);
}
function readRegexp() {
    const start = base_1.state.pos;
    let escaped;
    let inClass;
    for (;;) {
        if (base_1.state.pos >= base_1.input.length) {
            base_1.raise(start, "Unterminated regular expression");
        }
        const ch = base_1.input.charAt(base_1.state.pos);
        if (escaped) {
            escaped = false;
        }
        else {
            if (ch === "[") {
                inClass = true;
            }
            else if (ch === "]" && inClass) {
                inClass = false;
            }
            else if (ch === "/" && !inClass) {
                break;
            }
            escaped = ch === "\\";
        }
        ++base_1.state.pos;
    }
    ++base_1.state.pos;
    // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
    skipWord();
    finishToken(1024 /* regexp */);
}
// Read an integer. We allow any valid digit, including hex digits, plus numeric separators, and
// stop at any other character.
function readInt() {
    while (true) {
        const code = base_1.input.charCodeAt(base_1.state.pos);
        if ((code >= 48 /* digit0 */ && code <= 57 /* digit9 */) ||
            (code >= 97 /* lowercaseA */ && code <= 102 /* lowercaseF */) ||
            (code >= 65 /* uppercaseA */ && code <= 70 /* uppercaseF */) ||
            code === 95 /* underscore */) {
            base_1.state.pos++;
        }
        else {
            break;
        }
    }
}
function readRadixNumber() {
    let isBigInt = false;
    base_1.state.pos += 2; // 0x
    readInt();
    if (base_1.input.charCodeAt(base_1.state.pos) === 110 /* lowercaseN */) {
        ++base_1.state.pos;
        isBigInt = true;
    }
    if (isBigInt) {
        finishToken(512 /* bigint */);
        return;
    }
    finishToken(0 /* num */);
}
// Read an integer, octal integer, or floating-point number.
function readNumber(startsWithDot) {
    let isBigInt = false;
    if (!startsWithDot) {
        readInt();
    }
    let nextChar = base_1.input.charCodeAt(base_1.state.pos);
    if (nextChar === 46 /* dot */) {
        ++base_1.state.pos;
        readInt();
        nextChar = base_1.input.charCodeAt(base_1.state.pos);
    }
    if (nextChar === 69 /* uppercaseE */ || nextChar === 101 /* lowercaseE */) {
        nextChar = base_1.input.charCodeAt(++base_1.state.pos);
        if (nextChar === 43 /* plusSign */ || nextChar === 45 /* dash */) {
            ++base_1.state.pos;
        }
        readInt();
        nextChar = base_1.input.charCodeAt(base_1.state.pos);
    }
    if (nextChar === 110 /* lowercaseN */) {
        ++base_1.state.pos;
        isBigInt = true;
    }
    if (isBigInt) {
        finishToken(512 /* bigint */);
        return;
    }
    finishToken(0 /* num */);
}
function readString(quote) {
    base_1.state.pos++;
    for (;;) {
        if (base_1.state.pos >= base_1.input.length) {
            base_1.raise(base_1.state.start, "Unterminated string constant");
        }
        const ch = base_1.input.charCodeAt(base_1.state.pos);
        if (ch === 92 /* backslash */) {
            base_1.state.pos++;
        }
        else if (ch === quote) {
            break;
        }
        base_1.state.pos++;
    }
    base_1.state.pos++;
    finishToken(1536 /* string */);
}
// Reads template string tokens.
function readTmplToken() {
    for (;;) {
        if (base_1.state.pos >= base_1.input.length) {
            base_1.raise(base_1.state.start, "Unterminated template");
        }
        const ch = base_1.input.charCodeAt(base_1.state.pos);
        if (ch === 96 /* graveAccent */ ||
            (ch === 36 /* dollarSign */ && base_1.input.charCodeAt(base_1.state.pos + 1) === 123 /* leftCurlyBrace */)) {
            if (base_1.state.pos === base_1.state.start && match(11264 /* template */)) {
                if (ch === 36 /* dollarSign */) {
                    base_1.state.pos += 2;
                    finishToken(12800 /* dollarBraceL */);
                    return;
                }
                else {
                    ++base_1.state.pos;
                    finishToken(12288 /* backQuote */);
                    return;
                }
            }
            finishToken(11264 /* template */);
            return;
        }
        if (ch === 92 /* backslash */) {
            base_1.state.pos++;
        }
        base_1.state.pos++;
    }
}
// Skip to the end of the current word. Note that this is the same as the snippet at the end of
// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
// measurements.
function skipWord() {
    while (base_1.state.pos < base_1.input.length) {
        const ch = base_1.input.charCodeAt(base_1.state.pos);
        if (identifier_1.isIdentifierChar(ch)) {
            base_1.state.pos++;
        }
        else if (ch === 92 /* backslash */) {
            // \u
            base_1.state.pos += 2;
            if (base_1.input.charCodeAt(base_1.state.pos) === 123 /* leftCurlyBrace */) {
                while (base_1.input.charCodeAt(base_1.state.pos) !== 123 /* leftCurlyBrace */) {
                    base_1.state.pos++;
                }
                base_1.state.pos++;
            }
        }
        else {
            break;
        }
    }
}
exports.skipWord = skipWord;
