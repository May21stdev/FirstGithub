"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isIdentifier_1 = require("../util/isIdentifier");
const Transformer_1 = require("./Transformer");
class TypeScriptTransformer extends Transformer_1.default {
    constructor(rootTransformer, tokens) {
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
    }
    process() {
        const processedType = this.rootTransformer.processPossibleTypeRange();
        if (processedType) {
            return true;
        }
        if (this.tokens.matches1(51728 /* _public */) ||
            this.tokens.matches1(52752 /* _protected */) ||
            this.tokens.matches1(52240 /* _private */) ||
            this.tokens.matches1(50704 /* _abstract */) ||
            this.tokens.matches1(50192 /* _readonly */) ||
            this.tokens.matches1(28672 /* nonNullAssertion */)) {
            this.tokens.removeInitialToken();
            return true;
        }
        if (this.tokens.matches1(53776 /* _enum */) || this.tokens.matches2(38416 /* _const */, 53776 /* _enum */)) {
            this.processEnum();
            return true;
        }
        if (this.tokens.matches2(42512 /* _export */, 53776 /* _enum */) ||
            this.tokens.matches3(42512 /* _export */, 38416 /* _const */, 53776 /* _enum */)) {
            this.processEnum(true);
            return true;
        }
        return false;
    }
    processEnum(isExport = false) {
        // We might have "export const enum", so just remove all relevant tokens.
        this.tokens.removeInitialToken();
        while (this.tokens.matches1(38416 /* _const */) || this.tokens.matches1(53776 /* _enum */)) {
            this.tokens.removeToken();
        }
        const enumName = this.tokens.identifierName();
        this.tokens.removeToken();
        this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);
        this.tokens.copyExpectedToken(4096 /* braceL */);
        this.processEnumBody(enumName);
        this.tokens.copyExpectedToken(5120 /* braceR */);
        if (isExport) {
            this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);
        }
        else {
            this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
        }
    }
    /**
     * Rather than try to compute the actual enum values at compile time, we just create variables for
     * each one and let everything evaluate at runtime. There's some additional complexity due to
     * handling string literal names, including ones that happen to be valid identifiers.
     */
    processEnumBody(enumName) {
        let isPreviousValidIdentifier = false;
        let lastValueReference = null;
        while (true) {
            if (this.tokens.matches1(5120 /* braceR */)) {
                break;
            }
            const nameToken = this.tokens.currentToken();
            let name;
            let isValidIdentifier;
            let nameStringCode;
            if (nameToken.type === 2048 /* name */) {
                name = this.tokens.identifierNameForToken(nameToken);
                isValidIdentifier = true;
                nameStringCode = `"${name}"`;
            }
            else if (nameToken.type === 1536 /* string */) {
                name = this.tokens.stringValueForToken(nameToken);
                isValidIdentifier = isIdentifier_1.default(name);
                nameStringCode = this.tokens.code.slice(nameToken.start, nameToken.end);
            }
            else {
                throw new Error("Expected name or string at beginning of enum element.");
            }
            this.tokens.removeInitialToken();
            let valueIsString;
            let valueCode;
            if (this.tokens.matches1(14368 /* eq */)) {
                const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;
                if (rhsEndIndex == null) {
                    throw new Error("Expected rhsEndIndex on enum assign.");
                }
                this.tokens.removeToken();
                if (this.tokens.matches2(1536 /* string */, 7168 /* comma */) ||
                    this.tokens.matches2(1536 /* string */, 5120 /* braceR */)) {
                    valueIsString = true;
                }
                const startToken = this.tokens.currentToken();
                while (this.tokens.currentIndex() < rhsEndIndex) {
                    this.tokens.removeToken();
                }
                valueCode = this.tokens.code.slice(startToken.start, this.tokens.tokenAtRelativeIndex(-1).end);
            }
            else {
                valueIsString = false;
                if (lastValueReference != null) {
                    if (isPreviousValidIdentifier) {
                        valueCode = `${lastValueReference} + 1`;
                    }
                    else {
                        valueCode = `(${lastValueReference}) + 1`;
                    }
                }
                else {
                    valueCode = "0";
                }
            }
            if (this.tokens.matches1(7168 /* comma */)) {
                this.tokens.removeToken();
            }
            let valueReference;
            if (isValidIdentifier) {
                this.tokens.appendCode(`const ${name} = ${valueCode}; `);
                valueReference = name;
            }
            else {
                valueReference = valueCode;
            }
            if (valueIsString) {
                this.tokens.appendCode(`${enumName}[${nameStringCode}] = ${valueReference};`);
            }
            else {
                this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}] = ${valueReference}] = ${nameStringCode};`);
            }
            lastValueReference = valueReference;
            isPreviousValidIdentifier = isValidIdentifier;
        }
    }
}
exports.default = TypeScriptTransformer;
