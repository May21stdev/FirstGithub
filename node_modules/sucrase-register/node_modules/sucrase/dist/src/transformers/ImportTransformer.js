"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tokenizer_1 = require("../../sucrase-babylon/tokenizer");
const Transformer_1 = require("./Transformer");
class ImportTransformer extends Transformer_1.default {
    constructor(rootTransformer, tokens, importProcessor, shouldAddModuleExports) {
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.importProcessor = importProcessor;
        this.shouldAddModuleExports = shouldAddModuleExports;
        this.hadExport = false;
        this.hadNamedExport = false;
        this.hadDefaultExport = false;
    }
    getPrefixCode() {
        let prefix = this.importProcessor.getPrefixCode();
        if (this.hadExport) {
            prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
        }
        return prefix;
    }
    getSuffixCode() {
        if (this.shouldAddModuleExports && this.hadDefaultExport && !this.hadNamedExport) {
            return "\nmodule.exports = exports.default;\n";
        }
        return "";
    }
    process() {
        if (this.tokens.matches3(43024 /* _import */, 2048 /* name */, 14368 /* eq */)) {
            this.tokens.replaceToken("const");
            return true;
        }
        if (this.tokens.matches1(43024 /* _import */)) {
            this.processImport();
            return true;
        }
        if (this.tokens.matches2(42512 /* _export */, 14368 /* eq */)) {
            this.tokens.replaceToken("module.exports");
            return true;
        }
        if (this.tokens.matches1(42512 /* _export */) && !this.tokens.currentToken().isType) {
            this.hadExport = true;
            return this.processExport();
        }
        if (this.tokens.matches1(2048 /* name */) || this.tokens.matches1(26112 /* jsxName */)) {
            return this.processIdentifier();
        }
        if (this.tokens.matches1(14368 /* eq */)) {
            return this.processAssignment();
        }
        return false;
    }
    /**
     * Transform this:
     * import foo, {bar} from 'baz';
     * into
     * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
     *
     * The import code was already generated in the import preprocessing step, so
     * we just need to look it up.
     */
    processImport() {
        if (this.tokens.matches2(43024 /* _import */, 6144 /* parenL */)) {
            this.tokens.replaceToken("Promise.resolve().then(() => require");
            const contextId = this.tokens.currentToken().contextId;
            if (contextId == null) {
                throw new Error("Expected context ID on dynamic import invocation.");
            }
            this.tokens.copyToken();
            while (!this.tokens.matchesContextIdAndLabel(6656 /* parenR */, contextId)) {
                this.rootTransformer.processToken();
            }
            this.tokens.replaceToken("))");
            return;
        }
        const wasOnlyTypes = this.removeImportAndDetectIfType();
        if (wasOnlyTypes) {
            this.tokens.removeToken();
        }
        else {
            const path = this.tokens.stringValue();
            this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
            this.tokens.appendCode(this.importProcessor.claimImportCode(path));
        }
        if (this.tokens.matches1(7680 /* semi */)) {
            this.tokens.removeToken();
        }
    }
    /**
     * Erase this import, and return true if it was either of the form "import type" or contained only
     * "type" named imports. Such imports should not even do a side-effect import.
     *
     * The position should end at the import string.
     */
    removeImportAndDetectIfType() {
        this.tokens.removeInitialToken();
        if (this.tokens.matchesContextual(30 /* _type */) &&
            !this.tokens.matchesAtIndex(this.tokens.currentIndex() + 1, [7168 /* comma */]) &&
            !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, 10 /* _from */)) {
            // This is an "import type" statement, so exit early.
            this.removeRemainingImport();
            return true;
        }
        if (this.tokens.matches1(2048 /* name */) || this.tokens.matches1(24587 /* star */)) {
            // We have a default import or namespace import, so there must be some
            // non-type import.
            this.removeRemainingImport();
            return false;
        }
        if (this.tokens.matches1(1536 /* string */)) {
            // This is a bare import, so we should proceed with the import.
            return false;
        }
        let foundNonType = false;
        while (!this.tokens.matches1(1536 /* string */)) {
            // Check if any named imports are of the form "foo" or "foo as bar", with
            // no leading "type".
            if ((!foundNonType && this.tokens.matches1(4096 /* braceL */)) || this.tokens.matches1(7168 /* comma */)) {
                this.tokens.removeToken();
                if (this.tokens.matches2(2048 /* name */, 7168 /* comma */) ||
                    this.tokens.matches2(2048 /* name */, 5120 /* braceR */) ||
                    this.tokens.matches4(2048 /* name */, 2048 /* name */, 2048 /* name */, 7168 /* comma */) ||
                    this.tokens.matches4(2048 /* name */, 2048 /* name */, 2048 /* name */, 5120 /* braceR */)) {
                    foundNonType = true;
                }
            }
            this.tokens.removeToken();
        }
        return !foundNonType;
    }
    removeRemainingImport() {
        while (!this.tokens.matches1(1536 /* string */)) {
            this.tokens.removeToken();
        }
    }
    processIdentifier() {
        const token = this.tokens.currentToken();
        if (token.shadowsGlobal) {
            return false;
        }
        if (token.identifierRole === tokenizer_1.IdentifierRole.ObjectShorthand) {
            return this.processObjectShorthand();
        }
        if (token.identifierRole !== tokenizer_1.IdentifierRole.Access) {
            return false;
        }
        const replacement = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));
        if (!replacement) {
            return false;
        }
        // We need to change to (0, f) if this is a function call, so that it won't be interpreted as a
        // method access. This can also happen in situations like (f)(), so a following close-paren
        // should trigger this behavior as well if it eventually has an open-paren. In some cases, like
        // export assignees, we must NOT turn the identifier into a normal expression, so we need to
        // just to the regular replacement.
        let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
        while (possibleOpenParenIndex < this.tokens.tokens.length &&
            this.tokens.tokens[possibleOpenParenIndex].type === 6656 /* parenR */) {
            possibleOpenParenIndex++;
        }
        if (this.tokens.tokens[possibleOpenParenIndex].type === 6144 /* parenL */) {
            this.tokens.replaceToken(`(0, ${replacement})`);
        }
        else {
            this.tokens.replaceToken(replacement);
        }
        return true;
    }
    processObjectShorthand() {
        const identifier = this.tokens.identifierName();
        const replacement = this.importProcessor.getIdentifierReplacement(identifier);
        if (!replacement) {
            return false;
        }
        this.tokens.replaceToken(`${identifier}: ${replacement}`);
        return true;
    }
    processExport() {
        if (this.tokens.matches2(42512 /* _export */, 53776 /* _enum */) ||
            this.tokens.matches3(42512 /* _export */, 38416 /* _const */, 53776 /* _enum */)) {
            // Let the TypeScript transform handle it.
            return false;
        }
        if (this.tokens.matches2(42512 /* _export */, 31760 /* _default */)) {
            this.processExportDefault();
            this.hadDefaultExport = true;
            return true;
        }
        this.hadNamedExport = true;
        if (this.tokens.matches2(42512 /* _export */, 37392 /* _var */) ||
            this.tokens.matches2(42512 /* _export */, 37904 /* _let */) ||
            this.tokens.matches2(42512 /* _export */, 38416 /* _const */)) {
            this.processExportVar();
            return true;
        }
        else if (this.tokens.matches2(42512 /* _export */, 34320 /* _function */) ||
            this.tokens.matches3(42512 /* _export */, 2048 /* name */, 34320 /* _function */)) {
            this.processExportFunction();
            return true;
        }
        else if (this.tokens.matches2(42512 /* _export */, 41488 /* _class */) ||
            this.tokens.matches3(42512 /* _export */, 50704 /* _abstract */, 41488 /* _class */)) {
            this.processExportClass();
            return true;
        }
        else if (this.tokens.matches2(42512 /* _export */, 4096 /* braceL */)) {
            this.processExportBindings();
            return true;
        }
        else if (this.tokens.matches2(42512 /* _export */, 24587 /* star */)) {
            this.processExportStar();
            return true;
        }
        else {
            throw new Error("Unrecognized export syntax.");
        }
    }
    processAssignment() {
        const index = this.tokens.currentIndex();
        const identifierToken = this.tokens.tokens[index - 1];
        if (identifierToken.type !== 2048 /* name */) {
            return false;
        }
        if (this.tokens.matchesAtIndex(index - 2, [9216 /* dot */])) {
            return false;
        }
        if (index - 2 >= 0 &&
            [37392 /* _var */, 37904 /* _let */, 38416 /* _const */].includes(this.tokens.tokens[index - 2].type)) {
            // Declarations don't need an extra assignment. This doesn't avoid the
            // assignment for comma-separated declarations, but it's still correct
            // since the assignment is just redundant.
            return false;
        }
        const exportedName = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
        if (!exportedName) {
            return false;
        }
        this.tokens.copyToken();
        this.tokens.appendCode(` exports.${exportedName} =`);
        return true;
    }
    processExportDefault() {
        if (this.tokens.matches4(42512 /* _export */, 31760 /* _default */, 34320 /* _function */, 2048 /* name */) ||
            // export default aysnc function
            this.tokens.matches5(42512 /* _export */, 31760 /* _default */, 2048 /* name */, 34320 /* _function */, 2048 /* name */)) {
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            // Named function export case: change it to a top-level function
            // declaration followed by exports statement.
            const name = this.processNamedFunction();
            this.tokens.appendCode(` exports.default = ${name};`);
        }
        else if (this.tokens.matches4(42512 /* _export */, 31760 /* _default */, 41488 /* _class */, 2048 /* name */) ||
            this.tokens.matches5(42512 /* _export */, 31760 /* _default */, 50704 /* _abstract */, 41488 /* _class */, 2048 /* name */)) {
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            if (this.tokens.matches1(50704 /* _abstract */)) {
                this.tokens.removeToken();
            }
            const name = this.rootTransformer.processNamedClass();
            this.tokens.appendCode(` exports.default = ${name};`);
        }
        else if (this.tokens.matches3(42512 /* _export */, 31760 /* _default */, 13312 /* at */)) {
            throw new Error("Export default statements with decorators are not yet supported.");
        }
        else {
            this.tokens.replaceToken("exports.");
            this.tokens.copyToken();
            this.tokens.appendCode(" =");
        }
    }
    /**
     * Transform this:
     * export const x = 1;
     * into this:
     * exports.x = 1;
     */
    processExportVar() {
        this.tokens.removeInitialToken();
        this.tokens.removeToken();
        if (!this.tokens.matches1(2048 /* name */)) {
            throw new Error("Expected a regular identifier after export var/let/const.");
        }
        const name = this.tokens.identifierName();
        const replacement = this.importProcessor.getIdentifierReplacement(name);
        if (replacement === null) {
            throw new Error("Expected a replacement for `export var` syntax..");
        }
        this.tokens.replaceToken(replacement);
    }
    /**
     * Transform this:
     * export function foo() {}
     * into this:
     * function foo() {} exports.foo = foo;
     */
    processExportFunction() {
        this.tokens.replaceToken("");
        const name = this.processNamedFunction();
        this.tokens.appendCode(` exports.${name} = ${name};`);
    }
    /**
     * Skip past a function with a name and return that name.
     */
    processNamedFunction() {
        if (this.tokens.matches1(34320 /* _function */)) {
            this.tokens.copyToken();
        }
        else if (this.tokens.matches2(2048 /* name */, 34320 /* _function */)) {
            if (!this.tokens.matchesContextual(3 /* _async */)) {
                throw new Error("Expected async keyword in function export.");
            }
            this.tokens.copyToken();
            this.tokens.copyToken();
        }
        if (!this.tokens.matches1(2048 /* name */)) {
            throw new Error("Expected identifier for exported function name.");
        }
        const name = this.tokens.identifierName();
        this.tokens.copyToken();
        if (this.tokens.currentToken().isType) {
            this.tokens.removeInitialToken();
            while (this.tokens.currentToken().isType) {
                this.tokens.removeToken();
            }
        }
        this.tokens.copyExpectedToken(6144 /* parenL */);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(6656 /* parenR */);
        this.rootTransformer.processPossibleTypeRange();
        this.tokens.copyExpectedToken(4096 /* braceL */);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(5120 /* braceR */);
        return name;
    }
    /**
     * Transform this:
     * export class A {}
     * into this:
     * class A {} exports.A = A;
     */
    processExportClass() {
        this.tokens.removeInitialToken();
        if (this.tokens.matches1(50704 /* _abstract */)) {
            this.tokens.removeToken();
        }
        const name = this.rootTransformer.processNamedClass();
        this.tokens.appendCode(` exports.${name} = ${name};`);
    }
    /**
     * Transform this:
     * export {a, b as c};
     * into this:
     * exports.a = a; exports.c = b;
     *
     * OR
     *
     * Transform this:
     * export {a, b as c} from './foo';
     * into the pre-generated Object.defineProperty code from the ImportProcessor.
     */
    processExportBindings() {
        this.tokens.removeInitialToken();
        this.tokens.removeToken();
        const exportStatements = [];
        while (true) {
            const localName = this.tokens.identifierName();
            let exportedName;
            this.tokens.removeToken();
            if (this.tokens.matchesContextual(2 /* _as */)) {
                this.tokens.removeToken();
                exportedName = this.tokens.identifierName();
                this.tokens.removeToken();
            }
            else {
                exportedName = localName;
            }
            const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
            exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
            if (this.tokens.matches1(5120 /* braceR */)) {
                this.tokens.removeToken();
                break;
            }
            if (this.tokens.matches2(7168 /* comma */, 5120 /* braceR */)) {
                this.tokens.removeToken();
                this.tokens.removeToken();
                break;
            }
            else if (this.tokens.matches1(7168 /* comma */)) {
                this.tokens.removeToken();
            }
            else {
                throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
            }
        }
        if (this.tokens.matchesContextual(10 /* _from */)) {
            // This is an export...from, so throw away the normal named export code
            // and use the Object.defineProperty code from ImportProcessor.
            this.tokens.removeToken();
            const path = this.tokens.stringValue();
            this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
        }
        else {
            // This is a normal named export, so use that.
            this.tokens.appendCode(exportStatements.join(" "));
        }
        if (this.tokens.matches1(7680 /* semi */)) {
            this.tokens.removeToken();
        }
    }
    processExportStar() {
        this.tokens.removeInitialToken();
        while (!this.tokens.matches1(1536 /* string */)) {
            this.tokens.removeToken();
        }
        const path = this.tokens.stringValue();
        this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
        if (this.tokens.matches1(7680 /* semi */)) {
            this.tokens.removeToken();
        }
    }
}
exports.default = ImportTransformer;
