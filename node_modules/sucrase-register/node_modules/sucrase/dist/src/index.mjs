import { parse } from "../sucrase-babylon";
import identifyShadowedGlobals from "./identifyShadowedGlobals";
import ImportProcessor from "./ImportProcessor";
import NameManager from "./NameManager";
import TokenProcessor from "./TokenProcessor";
import RootTransformer from "./transformers/RootTransformer";
import formatTokens from "./util/formatTokens";
export function getVersion() {
    // eslint-disable-next-line
    return require("../../package.json").version;
}
export function transform(code, options) {
    try {
        const sucraseContext = getSucraseContext(code, options);
        return new RootTransformer(sucraseContext, options.transforms, options.filePath || null).transform();
    }
    catch (e) {
        if (options.filePath) {
            e.message = `Error transforming ${options.filePath}: ${e.message}`;
        }
        throw e;
    }
}
/**
 * Return a string representation of the sucrase tokens, mostly useful for
 * diagnostic purposes.
 */
export function getFormattedTokens(code, options) {
    const tokens = getSucraseContext(code, options).tokenProcessor.tokens;
    return formatTokens(code, tokens);
}
/**
 * Call into the parser/tokenizer and do some further preprocessing:
 * - Come up with a set of used names so that we can assign new names.
 * - Preprocess all import/export statements so we know which globals we are interested in.
 * - Compute situations where any of those globals are shadowed.
 *
 * In the future, some of these preprocessing steps can be skipped based on what actual work is
 * being done.
 */
function getSucraseContext(code, options) {
    const babylonPlugins = options.transforms.filter((t) => ["jsx", "typescript", "flow"].includes(t));
    const file = parse(code, babylonPlugins);
    const tokens = file.tokens;
    const scopes = file.scopes;
    const tokenProcessor = new TokenProcessor(code, tokens);
    const nameManager = new NameManager(tokenProcessor);
    nameManager.preprocessNames();
    const isTypeScript = options.transforms.includes("typescript");
    const importProcessor = new ImportProcessor(nameManager, tokenProcessor, isTypeScript);
    importProcessor.preprocessTokens();
    if (isTypeScript) {
        importProcessor.pruneTypeOnlyImports();
    }
    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());
    return { tokenProcessor, scopes, nameManager, importProcessor };
}
